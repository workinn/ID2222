2
Introduction to Operating Systems
If you are taking an undergraduate operating systems course, you should
already have some idea of what a computer program does when it runs.
If not, this book (and the corresponding course) is going to be difficult
— so you should probably stop reading this book, or run to the nearest bookstore and quickly consume the necessary background material
before continuing (both Patt & Patel [PP03] and Bryant & O’Hallaron
[BOH10] are pretty great books).
So what happens when a program runs?
Well, a running program does one very simple thing: it executes instructions. Many millions (and these days, even billions) of times every second, the processor fetches an instruction from memory, decodes
it (i.e., figures out which instruction this is), and executes it (i.e., it does
the thing that it is supposed to do, like add two numbers together, access
memory, check a condition, jump to a function, and so forth). After it is
done with this instruction, the processor moves on to the next instruction,
and so on, and so on, until the program finally completes1
.
Thus, we have just described the basics of the Von Neumann model of
computing2
. Sounds simple, right? But in this class, we will be learning
that while a program runs, a lot of other wild things are going on with
the primary goal of making the system easy to use.
There is a body of software, in fact, that is responsible for making it
easy to run programs (even allowing you to seemingly run many at the
same time), allowing programs to share memory, enabling programs to
interact with devices, and other fun stuff like that. That body of software
1Of course, modern processors do many bizarre and frightening things underneath the
hood to make programs run faster, e.g., executing multiple instructions at once, and even issuing and completing them out of order! But that is not our concern here; we are just concerned
with the simple model most programs assume: that instructions seemingly execute one at a
time, in an orderly and sequential fashion.
2Von Neumann was one of the early pioneers of computing systems. He also did pioneering work on game theory and atomic bombs, and played in the NBA for six years. OK, one of
those things isn’t true.
1
2 INTRODUCTION TO OPERATING SYSTEMS
THE CRUX OF THE PROBLEM:
HOW TO VIRTUALIZE RESOURCES
One central question we will answer in this book is quite simple: how
does the operating system virtualize resources? This is the crux of our
problem. Why the OS does this is not the main question, as the answer
should be obvious: it makes the system easier to use. Thus, we focus on
the how: what mechanisms and policies are implemented by the OS to
attain virtualization? How does the OS do so efficiently? What hardware
support is needed?
We will use the “crux of the problem”, in shaded boxes such as this one,
as a way to call out specific problems we are trying to solve in building
an operating system. Thus, within a note on a particular topic, you may
find one or more cruces (yes, this is the proper plural) which highlight the
problem. The details within the chapter, of course, present the solution,
or at least the basic parameters of a solution.
is called the operating system (OS)
3
, as it is in charge of making sure the
system operates correctly and efficiently in an easy-to-use manner.
The primary way the OS does this is through a general technique that
we call virtualization. That is, the OS takes a physical resource (such as
the processor, or memory, or a disk) and transforms it into a more general, powerful, and easy-to-use virtual form of itself. Thus, we sometimes
refer to the operating system as a virtual machine.
Of course, in order to allow users to tell the OS what to do and thus
make use of the features of the virtual machine (such as running a program, or allocating memory, or accessing a file), the OS also provides
some interfaces (APIs) that you can call. A typical OS, in fact, exports
a few hundred system calls that are available to applications. Because
the OS provides these calls to run programs, access memory and devices,
and other related actions, we also sometimes say that the OS provides a
standard library to applications.
Finally, because virtualization allows many programs to run (thus sharing the CPU), and many programs to concurrently access their own instructions and data (thus sharing memory), and many programs to access
devices (thus sharing disks and so forth), the OS is sometimes known as
a resource manager. Each of the CPU, memory, and disk is a resource
of the system; it is thus the operating system’s role to manage those resources, doing so efficiently or fairly or indeed with many other possible
goals in mind. To understand the role of the OS a little bit better, let’s take
a look at some examples.
3Another early name for the OS was the supervisor or even the master control program.
Apparently, the latter sounded a little overzealous (see the movie Tron for details) and thus,
thankfully, “operating system” caught on instead.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 3
1 #include <stdio.h>
2 #include <stdlib.h>
3 #include <sys/time.h>
4 #include <assert.h>
5 #include "common.h"
6
7 int
8 main(int argc, char *argv[])
9 {
10 if (argc != 2) {
11 fprintf(stderr, "usage: cpu <string>\n");
12 exit(1);
13 }
14 char *str = argv[1];
15 while (1) {
16 Spin(1);
17 printf("%s\n", str);
18 }
19 return 0;
20 }
Figure 2.1: Simple Example: Code That Loops And Prints (cpu.c)
2.1 Virtualizing The CPU
Figure 2.1 depicts our first program. It doesn’t do much. In fact, all
it does is call Spin(), a function that repeatedly checks the time and
returns once it has run for a second. Then, it prints out the string that the
user passed in on the command line, and repeats, forever.
Let’s say we save this file as cpu.c and decide to compile and run it
on a system with a single processor (or CPU as we will sometimes call it).
Here is what we will see:
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
ˆC
prompt>
Not too interesting of a run — the system begins running the program,
which repeatedly checks the time until a second has elapsed. Once a second has passed, the code prints the input string passed in by the user (in
this example, the letter “A”), and continues. Note the program will run
forever; by pressing “Control-c” (which on UNIX-based systems will terminate the program running in the foreground) we can halt the program.

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 INTRODUCTION TO OPERATING SYSTEMS
prompt> ./cpu A & ./cpu B & ./cpu C & ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
...
Figure 2.2: Running Many Programs At Once
Now, let’s do the same thing, but this time, let’s run many different instances of this same program. Figure 2.2 shows the results of this slightly
more complicated example.
Well, now things are getting a little more interesting. Even though we
have only one processor, somehow all four of these programs seem to be
running at the same time! How does this magic happen?4
It turns out that the operating system, with some help from the hardware, is in charge of this illusion, i.e., the illusion that the system has
a very large number of virtual CPUs. Turning a single CPU (or a small
set of them) into a seemingly infinite number of CPUs and thus allowing
many programs to seemingly run at once is what we call virtualizing the
CPU, the focus of the first major part of this book.
Of course, to run programs, and stop them, and otherwise tell the OS
which programs to run, there need to be some interfaces (APIs) that you
can use to communicate your desires to the OS. We’ll talk about these
APIs throughout this book; indeed, they are the major way in which most
users interact with operating systems.
You might also notice that the ability to run multiple programs at once
raises all sorts of new questions. For example, if two programs want to
run at a particular time, which should run? This question is answered by
a policy of the OS; policies are used in many different places within an
OS to answer these types of questions, and thus we will study them as
we learn about the basic mechanisms that operating systems implement
(such as the ability to run multiple programs at once). Hence the role of
the OS as a resource manager.
4Note how we ran four processes at the same time, by using the & symbol. Doing so runs a
job in the background in the zsh shell, which means that the user is able to immediately issue
their next command, which in this case is another program to run. If you’re using a different
shell (e.g., tcsh), it works slightly differently; read documentation online for details.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 5
1 #include <unistd.h>
2 #include <stdio.h>
3 #include <stdlib.h>
4 #include "common.h"
5
6 int
7 main(int argc, char *argv[])
8 {
9 int *p = malloc(sizeof(int)); // a1
10 assert(p != NULL);
11 printf("(%d) address pointed to by p: %p\n",
12 getpid(), p); // a2
13 *p = 0; // a3
14 while (1) {
15 Spin(1);
16 *p = *p + 1;
17 printf("(%d) p: %d\n", getpid(), *p); // a4
18 }
19 return 0;
20 }
Figure 2.3: A Program That Accesses Memory (mem.c)
2.2 Virtualizing Memory
Now let’s consider memory. The model of physical memory presented by modern machines is very simple. Memory is just an array of
bytes; to read memory, one must specify an address to be able to access
the data stored there; to write (or update) memory, one must also specify
the data to be written to the given address.
Memory is accessed all the time when a program is running. A program keeps all of its data structures in memory, and accesses them through
various instructions, like loads and stores or other explicit instructions
that access memory in doing their work. Don’t forget that each instruction of the program is in memory too; thus memory is accessed on each
instruction fetch.
Let’s take a look at a program (in Figure 2.3) that allocates some memory by calling malloc(). The output of this program can be found here:
prompt> ./mem
(2134) address pointed to by p: 0x200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 INTRODUCTION TO OPERATING SYSTEMS
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) address pointed to by p: 0x200000
(24114) address pointed to by p: 0x200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
Figure 2.4: Running The Memory Program Multiple Times
The program does a couple of things. First, it allocates some memory
(line a1). Then, it prints out the address of the memory (a2), and then
puts the number zero into the first slot of the newly allocated memory
(a3). Finally, it loops, delaying for a second and incrementing the value
stored at the address held in p. With every print statement, it also prints
out what is called the process identifier (the PID) of the running program.
This PID is unique per running process.
Again, this first result is not too interesting. The newly allocated memory is at address 0x200000. As the program runs, it slowly updates the
value and prints out the result.
Now, we again run multiple instances of this same program to see
what happens (Figure 2.4). We see from the example that each running
program has allocated memory at the same address (0x200000), and yet
each seems to be updating the value at 0x200000 independently! It is as
if each running program has its own private memory, instead of sharing
the same physical memory with other running programs5
.
Indeed, that is exactly what is happening here as the OS is virtualizing memory. Each process accesses its own private virtual address space
(sometimes just called its address space), which the OS somehow maps
onto the physical memory of the machine. A memory reference within
one running program does not affect the address space of other processes
(or the OS itself); as far as the running program is concerned, it has physical memory all to itself. The reality, however, is that physical memory is
a shared resource, managed by the operating system. Exactly how all of
this is accomplished is also the subject of the first part of this book, on the
topic of virtualization.
5
For this example to work, you need to make sure address-space randomization is disabled; randomization, as it turns out, can be a good defense against certain kinds of security
flaws. Read more about it on your own, especially if you want to learn how to break into
computer systems via stack-smashing attacks. Not that we would recommend such a thing...
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 7
2.3 Concurrency
1 #include <stdio.h>
2 #include <stdlib.h>
3 #include "common.h"
4 #include "common_threads.h"
5
6 volatile int counter = 0;
7 int loops;
8
9 void *worker(void *arg) {
10 int i;
11 for (i = 0; i < loops; i++) {
12 counter++;
13 }
14 return NULL;
15 }
16
17 int main(int argc, char *argv[]) {
18 if (argc != 2) {
19 fprintf(stderr, "usage: threads <value>\n");
20 exit(1);
21 }
22 loops = atoi(argv[1]);
23 pthread_t p1, p2;
24 printf("Initial value : %d\n", counter);
25
26 Pthread_create(&p1, NULL, worker, NULL);
27 Pthread_create(&p2, NULL, worker, NULL);
28 Pthread_join(p1, NULL);
29 Pthread_join(p2, NULL);
30 printf("Final value : %d\n", counter);
31 return 0;
32 }
Figure 2.5: A Multi-threaded Program (threads.c)
Another main theme of this book is concurrency. We use this conceptual term to refer to a host of problems that arise, and must be addressed,
when working on many things at once (i.e., concurrently) in the same
program. The problems of concurrency arose first within the operating
system itself; as you can see in the examples above on virtualization, the
OS is juggling many things at once, first running one process, then another, and so forth. As it turns out, doing so leads to some deep and
interesting problems.
Unfortunately, the problems of concurrency are no longer limited just
to the OS itself. Indeed, modern multi-threaded programs exhibit the
same problems. Let us demonstrate with an example of a multi-threaded
program (Figure 2.5).

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 INTRODUCTION TO OPERATING SYSTEMS
Although you might not understand this example fully at the moment
(and we’ll learn a lot more about it in later chapters, in the section of the
book on concurrency), the basic idea is simple. The main program creates
two threads using Pthread create()6
. You can think of a thread as a
function running within the same memory space as other functions, with
more than one of them active at a time. In this example, each thread starts
running in a routine called worker(), in which it simply increments a
counter in a loop for loops number of times.
Below is a transcript of what happens when we run this program with
the input value for the variable loops set to 1000. The value of loops
determines how many times each of the two workers will increment the
shared counter in a loop. When the program is run with the value of
loops set to 1000, what do you expect the final value of counter to be?
prompt> gcc -o thread thread.c -Wall -pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
As you probably guessed, when the two threads are finished, the final
value of the counter is 2000, as each thread incremented the counter 1000
times. Indeed, when the input value of loops is set to N, we would
expect the final output of the program to be 2N. But life is not so simple,
as it turns out. Let’s run the same program, but with higher values for
loops, and see what happens:
prompt> ./thread 100000
Initial value : 0
Final value : 143012 // huh??
prompt> ./thread 100000
Initial value : 0
Final value : 137298 // what the??
In this run, when we gave an input value of 100,000, instead of getting
a final value of 200,000, we instead first get 143,012. Then, when we run
the program a second time, we not only again get the wrong value, but
also a different value than the last time. In fact, if you run the program
over and over with high values of loops, you may find that sometimes
you even get the right answer! So why is this happening?
As it turns out, the reason for these odd and unusual outcomes relate
to how instructions are executed, which is one at a time. Unfortunately, a
key part of the program above, where the shared counter is incremented,
6The actual call should be to lower-case pthread create(); the upper-case version is
our own wrapper that calls pthread create() and makes sure that the return code indicates
that the call succeeded. See the code for details.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 9
THE CRUX OF THE PROBLEM:
HOW TO BUILD CORRECT CONCURRENT PROGRAMS
When there are many concurrently executing threads within the same
memory space, how can we build a correctly working program? What
primitives are needed from the OS? What mechanisms should be provided by the hardware? How can we use them to solve the problems of
concurrency?
takes three instructions: one to load the value of the counter from memory into a register, one to increment it, and one to store it back into memory. Because these three instructions do not execute atomically (all at
once), strange things can happen. It is this problem of concurrency that
we will address in great detail in the second part of this book.
2.4 Persistence
The third major theme of the course is persistence. In system memory,
data can be easily lost, as devices such as DRAM store values in a volatile
manner; when power goes away or the system crashes, any data in memory is lost. Thus, we need hardware and software to be able to store data
persistently; such storage is thus critical to any system as users care a
great deal about their data.
The hardware comes in the form of some kind of input/output or I/O
device; in modern systems, a hard drive is a common repository for longlived information, although solid-state drives (SSDs) are making headway in this arena as well.
The software in the operating system that usually manages the disk is
called the file system; it is thus responsible for storing any files the user
creates in a reliable and efficient manner on the disks of the system.
Unlike the abstractions provided by the OS for the CPU and memory,
the OS does not create a private, virtualized disk for each application.
Rather, it is assumed that often times, users will want to share information that is in files. For example, when writing a C program, you might
first use an editor (e.g., Emacs7
) to create and edit the C file (emacs -nw
main.c). Once done, you might use the compiler to turn the source code
into an executable (e.g., gcc -o main main.c). When you’re finished,
you might run the new executable (e.g., ./main). Thus, you can see how
files are shared across different processes. First, Emacs creates a file that
serves as input to the compiler; the compiler uses that input file to create
a new executable file (in many steps — take a compiler course for details);
finally, the new executable is then run. And thus a new program is born!
7You should be using Emacs. If you are using vi, there is probably something wrong with
you. If you are using something that is not a real code editor, that is even worse.

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 INTRODUCTION TO OPERATING SYSTEMS
1 #include <stdio.h>
2 #include <unistd.h>
3 #include <assert.h>
4 #include <fcntl.h>
5 #include <sys/types.h>
6
7 int main(int argc, char *argv[]) {
8 int fd = open("/tmp/file", O_WRONLY|O_CREAT|O_TRUNC,
9 S_IRWXU);
10 assert(fd > -1);
11 int rc = write(fd, "hello world\n", 13);
12 assert(rc == 13);
13 close(fd);
14 return 0;
15 }
Figure 2.6: A Program That Does I/O (io.c)
To understand this better, let’s look at some code. Figure 2.6 presents
code to create a file (/tmp/file) that contains the string “hello world”.
To accomplish this task, the program makes three calls into the operating system. The first, a call to open(), opens the file and creates it; the
second, write(), writes some data to the file; the third, close(), simply closes the file thus indicating the program won’t be writing any more
data to it. These system calls are routed to the part of the operating system called the file system, which then handles the requests and returns
some kind of error code to the user.
You might be wondering what the OS does in order to actually write
to disk. We would show you but you’d have to promise to close your
eyes first; it is that unpleasant. The file system has to do a fair bit of work:
first figuring out where on disk this new data will reside, and then keeping track of it in various structures the file system maintains. Doing so
requires issuing I/O requests to the underlying storage device, to either
read existing structures or update (write) them. As anyone who has written a device driver8
knows, getting a device to do something on your
behalf is an intricate and detailed process. It requires a deep knowledge
of the low-level device interface and its exact semantics. Fortunately, the
OS provides a standard and simple way to access devices through its system calls. Thus, the OS is sometimes seen as a standard library.
Of course, there are many more details in how devices are accessed,
and how file systems manage data persistently atop said devices. For
performance reasons, most file systems first delay such writes for a while,
hoping to batch them into larger groups. To handle the problems of system crashes during writes, most file systems incorporate some kind of
intricate write protocol, such as journaling or copy-on-write, carefully
8A device driver is some code in the operating system that knows how to deal with a
specific device. We will talk more about devices and device drivers later.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 11
THE CRUX OF THE PROBLEM:
HOW TO STORE DATA PERSISTENTLY
The file system is the part of the OS in charge of managing persistent data.
What techniques are needed to do so correctly? What mechanisms and
policies are required to do so with high performance? How is reliability
achieved, in the face of failures in hardware and software?
ordering writes to disk to ensure that if a failure occurs during the write
sequence, the system can recover to reasonable state afterwards. To make
different common operations efficient, file systems employ many different data structures and access methods, from simple lists to complex btrees. If all of this doesn’t make sense yet, good! We’ll be talking about
all of this quite a bit more in the third part of this book on persistence,
where we’ll discuss devices and I/O in general, and then disks, RAIDs,
and file systems in great detail.
2.5 Design Goals
So now you have some idea of what an OS actually does: it takes physical resources, such as a CPU, memory, or disk, and virtualizes them. It
handles tough and tricky issues related to concurrency. And it stores files
persistently, thus making them safe over the long-term. Given that we
want to build such a system, we want to have some goals in mind to help
focus our design and implementation and make trade-offs as necessary;
finding the right set of trade-offs is a key to building systems.
One of the most basic goals is to build up some abstractions in order
to make the system convenient and easy to use. Abstractions are fundamental to everything we do in computer science. Abstraction makes
it possible to write a large program by dividing it into small and understandable pieces, to write such a program in a high-level language like
C
9 without thinking about assembly, to write code in assembly without
thinking about logic gates, and to build a processor out of gates without
thinking too much about transistors. Abstraction is so fundamental that
sometimes we forget its importance, but we won’t here; thus, in each section, we’ll discuss some of the major abstractions that have developed
over time, giving you a way to think about pieces of the OS.
One goal in designing and implementing an operating system is to
provide high performance; another way to say this is our goal is to minimize the overheads of the OS. Virtualization and making the system easy
to use are well worth it, but not at any cost; thus, we must strive to provide virtualization and other OS features without excessive overheads.
9
Some of you might object to calling C a high-level language. Remember this is an OS
course, though, where we’re simply happy not to have to code in assembly all the time!

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 INTRODUCTION TO OPERATING SYSTEMS
These overheads arise in a number of forms: extra time (more instructions) and extra space (in memory or on disk). We’ll seek solutions that
minimize one or the other or both, if possible. Perfection, however, is not
always attainable, something we will learn to notice and (where appropriate) tolerate.
Another goal will be to provide protection between applications, as
well as between the OS and applications. Because we wish to allow
many programs to run at the same time, we want to make sure that the
malicious or accidental bad behavior of one does not harm others; we
certainly don’t want an application to be able to harm the OS itself (as
that would affect all programs running on the system). Protection is at
the heart of one of the main principles underlying an operating system,
which is that of isolation; isolating processes from one another is the key
to protection and thus underlies much of what an OS must do.
The operating system must also run non-stop; when it fails, all applications running on the system fail as well. Because of this dependence,
operating systems often strive to provide a high degree of reliability. As
operating systems grow evermore complex (sometimes containing millions of lines of code), building a reliable operating system is quite a challenge — and indeed, much of the on-going research in the field (including
some of our own work [BS+09, SS+10]) focuses on this exact problem.
Other goals make sense: energy-efficiency is important in our increasingly green world; security (an extension of protection, really) against
malicious applications is critical, especially in these highly-networked
times; mobility is increasingly important as OSes are run on smaller and
smaller devices. Depending on how the system is used, the OS will have
different goals and thus likely be implemented in at least slightly different ways. However, as we will see, many of the principles we will present
on how to build an OS are useful on a range of different devices.
2.6 Some History
Before closing this introduction, let us present a brief history of how
operating systems developed. Like any system built by humans, good
ideas accumulated in operating systems over time, as engineers learned
what was important in their design. Here, we discuss a few major developments. For a richer treatment, see Brinch Hansen’s excellent history of
operating systems [BH00].
Early Operating Systems: Just Libraries
In the beginning, the operating system didn’t do too much. Basically,
it was just a set of libraries of commonly-used functions; for example,
instead of having each programmer of the system write low-level I/O
handling code, the “OS” would provide such APIs, and thus make life
easier for the developer.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 13
Usually, on these old mainframe systems, one program ran at a time,
as controlled by a human operator. Much of what you think a modern
OS would do (e.g., deciding what order to run jobs in) was performed by
this operator. If you were a smart developer, you would be nice to this
operator, so that they might move your job to the front of the queue.
This mode of computing was known as batch processing, as a number
of jobs were set up and then run in a “batch” by the operator. Computers,
as of that point, were not used in an interactive manner, because of cost:
it was simply too expensive to let a user sit in front of the computer and
use it, as most of the time it would just sit idle then, costing the facility
hundreds of thousands of dollars per hour [BH00].
Beyond Libraries: Protection
In moving beyond being a simple library of commonly-used services, operating systems took on a more central role in managing machines. One
important aspect of this was the realization that code run on behalf of the
OS was special; it had control of devices and thus should be treated differently than normal application code. Why is this? Well, imagine if you
allowed any application to read from anywhere on the disk; the notion of
privacy goes out the window, as any program could read any file. Thus,
implementing a file system (to manage your files) as a library makes little
sense. Instead, something else was needed.
Thus, the idea of a system call was invented, pioneered by the Atlas
computing system [K+61,L78]. Instead of providing OS routines as a library (where you just make a procedure call to access them), the idea here
was to add a special pair of hardware instructions and hardware state to
make the transition into the OS a more formal, controlled process.
The key difference between a system call and a procedure call is that
a system call transfers control (i.e., jumps) into the OS while simultaneously raising the hardware privilege level. User applications run in what
is referred to as user mode which means the hardware restricts what applications can do; for example, an application running in user mode can’t
typically initiate an I/O request to the disk, access any physical memory
page, or send a packet on the network. When a system call is initiated
(usually through a special hardware instruction called a trap), the hardware transfers control to a pre-specified trap handler (that the OS set up
previously) and simultaneously raises the privilege level to kernel mode.
In kernel mode, the OS has full access to the hardware of the system and
thus can do things like initiate an I/O request or make more memory
available to a program. When the OS is done servicing the request, it
passes control back to the user via a special return-from-trap instruction,
which reverts to user mode while simultaneously passing control back to
where the application left off.

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 INTRODUCTION TO OPERATING SYSTEMS
The Era of Multiprogramming
Where operating systems really took off was in the era of computing beyond the mainframe, that of the minicomputer. Classic machines like
the PDP family from Digital Equipment made computers hugely more
affordable; thus, instead of having one mainframe per large organization,
now a smaller collection of people within an organization could likely
have their own computer. Not surprisingly, one of the major impacts of
this drop in cost was an increase in developer activity; more smart people
got their hands on computers and thus made computer systems do more
interesting and beautiful things.
In particular, multiprogramming became commonplace due to the desire to make better use of machine resources. Instead of just running one
job at a time, the OS would load a number of jobs into memory and switch
rapidly between them, thus improving CPU utilization. This switching
was particularly important because I/O devices were slow; having a program wait on the CPU while its I/O was being serviced was a waste of
CPU time. Instead, why not switch to another job and run it for a while?
The desire to support multiprogramming and overlap in the presence
of I/O and interrupts forced innovation in the conceptual development of
operating systems along a number of directions. Issues such as memory
protection became important; we wouldn’t want one program to be able
to access the memory of another program. Understanding how to deal
with the concurrency issues introduced by multiprogramming was also
critical; making sure the OS was behaving correctly despite the presence
of interrupts is a great challenge. We will study these issues and related
topics later in the book.
One of the major practical advances of the time was the introduction
of the UNIX operating system, primarily thanks to Ken Thompson (and
Dennis Ritchie) at Bell Labs (yes, the phone company). UNIX took many
good ideas from different operating systems (particularly from Multics
[O72], and some from systems like TENEX [B+72] and the Berkeley TimeSharing System [S+68]), but made them simpler and easier to use. Soon
this team was shipping tapes containing UNIX source code to people
around the world, many of whom then got involved and added to the
system themselves; see the Aside (next page) for more detail10
.
The Modern Era
Beyond the minicomputer came a new type of machine, cheaper, faster,
and for the masses: the personal computer, or PC as we call it today. Led
by Apple’s early machines (e.g., the Apple II) and the IBM PC, this new
breed of machine would soon become the dominant force in computing,
10We’ll use asides and other related text boxes to call attention to various items that don’t
quite fit the main flow of the text. Sometimes, we’ll even use them just to make a joke, because
why not have a little fun along the way? Yes, many of the jokes are bad.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 15
ASIDE: THE IMPORTANCE OF UNIX
It is difficult to overstate the importance of UNIX in the history of operating systems. Influenced by earlier systems (in particular, the famous
Multics system from MIT), UNIX brought together many great ideas and
made a system that was both simple and powerful.
Underlying the original “Bell Labs” UNIX was the unifying principle of
building small powerful programs that could be connected together to
form larger workflows. The shell, where you type commands, provided
primitives such as pipes to enable such meta-level programming, and
thus it became easy to string together programs to accomplish a bigger task. For example, to find lines of a text file that have the word
“foo” in them, and then to count how many such lines exist, you would
type: grep foo file.txt|wc -l, thus using the grep and wc (word
count) programs to achieve your task.
The UNIX environment was friendly for programmers and developers
alike, also providing a compiler for the new C programming language.
Making it easy for programmers to write their own programs, as well as
share them, made UNIX enormously popular. And it probably helped a
lot that the authors gave out copies for free to anyone who asked, an early
form of open-source software.
Also of critical importance was the accessibility and readability of the
code. Having a beautiful, small kernel written in C invited others to play
with the kernel, adding new and cool features. For example, an enterprising group at Berkeley, led by Bill Joy, made a wonderful distribution
(the Berkeley Systems Distribution, or BSD) which had some advanced
virtual memory, file system, and networking subsystems. Joy later cofounded Sun Microsystems.
Unfortunately, the spread of UNIX was slowed a bit as companies tried to
assert ownership and profit from it, an unfortunate (but common) result
of lawyers getting involved. Many companies had their own variants:
SunOS from Sun Microsystems, AIX from IBM, HPUX (a.k.a. “H-Pucks”)
from HP, and IRIX from SGI. The legal wrangling among AT&T/Bell
Labs and these other players cast a dark cloud over UNIX, and many
wondered if it would survive, especially as Windows was introduced and
took over much of the PC market...
as their low-cost enabled one machine per desktop instead of a shared
minicomputer per workgroup.
Unfortunately, for operating systems, the PC at first represented a
great leap backwards, as early systems forgot (or never knew of) the
lessons learned in the era of minicomputers. For example, early operating systems such as DOS (the Disk Operating System, from Microsoft)
didn’t think memory protection was important; thus, a malicious (or perhaps just a poorly-programmed) application could scribble all over mem-

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
16 INTRODUCTION TO OPERATING SYSTEMS
ASIDE: AND THEN CAME LINUX
Fortunately for UNIX, a young Finnish hacker named Linus Torvalds decided to write his own version of UNIX which borrowed heavily on the
principles and ideas behind the original system, but not from the code
base, thus avoiding issues of legality. He enlisted help from many others
around the world, took advantage of the sophisticated GNU tools that
already existed [G85], and soon Linux was born (as well as the modern
open-source software movement).
As the internet era came into place, most companies (such as Google,
Amazon, Facebook, and others) chose to run Linux, as it was free and
could be readily modified to suit their needs; indeed, it is hard to imagine the success of these new companies had such a system not existed.
As smart phones became a dominant user-facing platform, Linux found
a stronghold there too (via Android), for many of the same reasons. And
Steve Jobs took his UNIX-based NeXTStep operating environment with
him to Apple, thus making UNIX popular on desktops (though many
users of Apple technology are probably not even aware of this fact). Thus
UNIX lives on, more important today than ever before. The computing
gods, if you believe in them, should be thanked for this wonderful outcome.
ory. The first generations of the Mac OS (v9 and earlier) took a cooperative approach to job scheduling; thus, a thread that accidentally got stuck
in an infinite loop could take over the entire system, forcing a reboot. The
painful list of OS features missing in this generation of systems is long,
too long for a full discussion here.
Fortunately, after some years of suffering, the old features of minicomputer operating systems started to find their way onto the desktop.
For example, Mac OS X/macOS has UNIX at its core, including all of the
features one would expect from such a mature system. Windows has similarly adopted many of the great ideas in computing history, starting in
particular with Windows NT, a great leap forward in Microsoft OS technology. Even today’s cell phones run operating systems (such as Linux)
that are much more like what a minicomputer ran in the 1970s than what
a PC ran in the 1980s (thank goodness); it is good to see that the good
ideas developed in the heyday of OS development have found their way
into the modern world. Even better is that these ideas continue to develop, providing more features and making modern systems even better
for users and applications.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 17
2.7 Summary
Thus, we have an introduction to the OS. Today’s operating systems
make systems relatively easy to use, and virtually all operating systems
you use today have been influenced by the developments we will discuss
throughout the book.
Unfortunately, due to time constraints, there are a number of parts of
the OS we won’t cover in the book. For example, there is a lot of networking code in the operating system; we leave it to you to take the networking class to learn more about that. Similarly, graphics devices are
particularly important; take the graphics course to expand your knowledge in that direction. Finally, some operating system books talk a great
deal about security; we will do so in the sense that the OS must provide
protection between running programs and give users the ability to protect their files, but we won’t delve into deeper security issues that one
might find in a security course.
However, there are many important topics that we will cover, including the basics of virtualization of the CPU and memory, concurrency, and
persistence via devices and file systems. Don’t worry! While there is a
lot of ground to cover, most of it is quite cool, and at the end of the road,
you’ll have a new appreciation for how computer systems really work.
Now get to work!

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
18 INTRODUCTION TO OPERATING SYSTEMS
References
[BS+09] “Tolerating File-System Mistakes with EnvyFS” by L. Bairavasundaram, S. Sundararaman, A. Arpaci-Dusseau, R. Arpaci-Dusseau. USENIX ’09, San Diego, CA, June 2009. A fun
paper about using multiple file systems at once to tolerate a mistake in any one of them.
[BH00] “The Evolution of Operating Systems” by P. Brinch Hansen. In ’Classic Operating
Systems: From Batch Processing to Distributed Systems.’ Springer-Verlag, New York, 2000.
This essay provides an intro to a wonderful collection of papers about historically significant systems.
[B+72] “TENEX, A Paged Time Sharing System for the PDP-10” by D. Bobrow, J. Burchfiel, D.
Murphy, R. Tomlinson. CACM, Volume 15, Number 3, March 1972. TENEX has much of the
machinery found in modern operating systems; read more about it to see how much innovation was
already in place in the early 1970’s.
[B75] “The Mythical Man-Month” by F. Brooks. Addison-Wesley, 1975. A classic text on software
engineering; well worth the read.
[BOH10] “Computer Systems: A Programmer’s Perspective” by R. Bryant and D. O’Hallaron.
Addison-Wesley, 2010. Another great intro to how computer systems work. Has a little bit of overlap
with this book — so if you’d like, you can skip the last few chapters of that book, or simply read them to
get a different perspective on some of the same material. After all, one good way to build up your own
knowledge is to hear as many other perspectives as possible, and then develop your own opinion and
thoughts on the matter. You know, by thinking!
[G85] “The GNU Manifesto” by R. Stallman. 1985. www.gnu.org/gnu/manifesto.html.
A huge part of Linux’s success was no doubt the presence of an excellent compiler, gcc, and other
relevant pieces of open software, thanks to the GNU effort headed by Stallman. Stallman is a visionary
when it comes to open source, and this manifesto lays out his thoughts as to why.
[K+61] “One-Level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner.
IRE Transactions on Electronic Computers, April 1962. The Atlas pioneered much of what you see
in modern systems. However, this paper is not the best read. If you were to only read one, you might
try the historical perspective below [L78].
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. A nice piece of history on the early development of computer systems and the pioneering efforts of the Atlas. Of course, one could go back and
read the Atlas papers themselves, but this paper provides a great overview and adds some historical
perspective.
[O72] “The Multics System: An Examination of its Structure” by Elliott Organick. MIT Press,
1972. A great overview of Multics. So many good ideas, and yet it was an over-designed system,
shooting for too much, and thus never really worked. A classic example of what Fred Brooks would call
the “second-system effect” [B75].
[PP03] “Introduction to Computing Systems: From Bits and Gates to C and Beyond” by Yale
N. Patt, Sanjay J. Patel. McGraw-Hill, 2003. One of our favorite intro to computing systems books.
Starts at transistors and gets you all the way up to C; the early material is particularly great.
[RT74] “The UNIX Time-Sharing System” by Dennis M. Ritchie, Ken Thompson. CACM, Volume 17: 7, July 1974. A great summary of UNIX written as it was taking over the world of computing,
by the people who wrote it.
[S68] “SDS 940 Time-Sharing System” by Scientific Data Systems. TECHNICAL MANUAL,
SDS 90 11168, August 1968. Yes, a technical manual was the best we could find. But it is fascinating
to read these old system documents, and see how much was already in place in the late 1960’s. One of
the minds behind the Berkeley Time-Sharing System (which eventually became the SDS system) was
Butler Lampson, who later won a Turing award for his contributions in systems.
[SS+10] “Membrane: Operating System Support for Restartable File Systems” by S. Sundararaman, S. Subramanian, A. Rajimwale, A. Arpaci-Dusseau, R. Arpaci-Dusseau, M. Swift. FAST
’10, San Jose, CA, February 2010. The great thing about writing your own class notes: you can advertise your own research. But this paper is actually pretty neat — when a file system hits a bug and
crashes, Membrane auto-magically restarts it, all without applications or the rest of the system being
affected.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 19
Homework
Most (and eventually, all) chapters of this book have homework sections at the end. Doing these homeworks is important, as each lets you,
the reader, gain more experience with the concepts presented within the
chapter.
There are two types of homeworks. The first is based on simulation. A
simulation of a computer system is just a simple program that pretends to
do some of the interesting parts of what a real system does, and then report some output metrics to show how the system behaves. For example,
a hard drive simulator might take a series of requests, simulate how long
they would take to get serviced by a hard drive with certain performance
characteristics, and then report the average latency of the requests.
The cool thing about simulations is they let you easily explore how
systems behave without the difficulty of running a real system. Indeed,
they even let you create systems that cannot exist in the real world (for
example, a hard drive with unimaginably fast performance), and thus see
the potential impact of future technologies.
Of course, simulations are not without their downsides. By their very
nature, simulations are just approximations of how a real system behaves.
If an important aspect of real-world behavior is omitted, the simulation
will report bad results. Thus, results from a simulation should always be
treated with some suspicion. In the end, how a system behaves in the real
world is what matters.
The second type of homework requires interaction with real-world
code. Some of these homeworks are measurement focused, whereas others just require some small-scale development and experimentation. Both
are just small forays into the larger world you should be getting into,
which is how to write systems code in C on UNIX-based systems. Indeed,
larger-scale projects, which go beyond these homeworks, are needed to
push you in this direction; thus, beyond just doing homeworks, we strongly
recommend you do projects to solidify your systems skills. See this page
(https://github.com/remzi-arpacidusseau/ostep-projects)
for some projects.
To do these homeworks, you likely have to be on a UNIX-based machine, running either Linux, macOS, or some similar system. It should
also have a C compiler installed (e.g., gcc) as well as Python. You should
also know how to edit code in a real code editor of some kind.

2
Introduction to Operating Systems
If you are taking an undergraduate operating systems course, you should
already have some idea of what a computer program does when it runs.
If not, this book (and the corresponding course) is going to be difficult
— so you should probably stop reading this book, or run to the nearest bookstore and quickly consume the necessary background material
before continuing (both Patt & Patel [PP03] and Bryant & O’Hallaron
[BOH10] are pretty great books).
So what happens when a program runs?
Well, a running program does one very simple thing: it executes instructions. Many millions (and these days, even billions) of times every second, the processor fetches an instruction from memory, decodes
it (i.e., figures out which instruction this is), and executes it (i.e., it does
the thing that it is supposed to do, like add two numbers together, access
memory, check a condition, jump to a function, and so forth). After it is
done with this instruction, the processor moves on to the next instruction,
and so on, and so on, until the program finally completes1
.
Thus, we have just described the basics of the Von Neumann model of
computing2
. Sounds simple, right? But in this class, we will be learning
that while a program runs, a lot of other wild things are going on with
the primary goal of making the system easy to use.
There is a body of software, in fact, that is responsible for making it
easy to run programs (even allowing you to seemingly run many at the
same time), allowing programs to share memory, enabling programs to
interact with devices, and other fun stuff like that. That body of software
1Of course, modern processors do many bizarre and frightening things underneath the
hood to make programs run faster, e.g., executing multiple instructions at once, and even issuing and completing them out of order! But that is not our concern here; we are just concerned
with the simple model most programs assume: that instructions seemingly execute one at a
time, in an orderly and sequential fashion.
2Von Neumann was one of the early pioneers of computing systems. He also did pioneering work on game theory and atomic bombs, and played in the NBA for six years. OK, one of
those things isn’t true.
1
2 INTRODUCTION TO OPERATING SYSTEMS
THE CRUX OF THE PROBLEM:
HOW TO VIRTUALIZE RESOURCES
One central question we will answer in this book is quite simple: how
does the operating system virtualize resources? This is the crux of our
problem. Why the OS does this is not the main question, as the answer
should be obvious: it makes the system easier to use. Thus, we focus on
the how: what mechanisms and policies are implemented by the OS to
attain virtualization? How does the OS do so efficiently? What hardware
support is needed?
We will use the “crux of the problem”, in shaded boxes such as this one,
as a way to call out specific problems we are trying to solve in building
an operating system. Thus, within a note on a particular topic, you may
find one or more cruces (yes, this is the proper plural) which highlight the
problem. The details within the chapter, of course, present the solution,
or at least the basic parameters of a solution.
is called the operating system (OS)
3
, as it is in charge of making sure the
system operates correctly and efficiently in an easy-to-use manner.
The primary way the OS does this is through a general technique that
we call virtualization. That is, the OS takes a physical resource (such as
the processor, or memory, or a disk) and transforms it into a more general, powerful, and easy-to-use virtual form of itself. Thus, we sometimes
refer to the operating system as a virtual machine.
Of course, in order to allow users to tell the OS what to do and thus
make use of the features of the virtual machine (such as running a program, or allocating memory, or accessing a file), the OS also provides
some interfaces (APIs) that you can call. A typical OS, in fact, exports
a few hundred system calls that are available to applications. Because
the OS provides these calls to run programs, access memory and devices,
and other related actions, we also sometimes say that the OS provides a
standard library to applications.
Finally, because virtualization allows many programs to run (thus sharing the CPU), and many programs to concurrently access their own instructions and data (thus sharing memory), and many programs to access
devices (thus sharing disks and so forth), the OS is sometimes known as
a resource manager. Each of the CPU, memory, and disk is a resource
of the system; it is thus the operating system’s role to manage those resources, doing so efficiently or fairly or indeed with many other possible
goals in mind. To understand the role of the OS a little bit better, let’s take
a look at some examples.
3Another early name for the OS was the supervisor or even the master control program.
Apparently, the latter sounded a little overzealous (see the movie Tron for details) and thus,
thankfully, “operating system” caught on instead.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 3
1 #include <stdio.h>
2 #include <stdlib.h>
3 #include <sys/time.h>
4 #include <assert.h>
5 #include "common.h"
6
7 int
8 main(int argc, char *argv[])
9 {
10 if (argc != 2) {
11 fprintf(stderr, "usage: cpu <string>\n");
12 exit(1);
13 }
14 char *str = argv[1];
15 while (1) {
16 Spin(1);
17 printf("%s\n", str);
18 }
19 return 0;
20 }
Figure 2.1: Simple Example: Code That Loops And Prints (cpu.c)
2.1 Virtualizing The CPU
Figure 2.1 depicts our first program. It doesn’t do much. In fact, all
it does is call Spin(), a function that repeatedly checks the time and
returns once it has run for a second. Then, it prints out the string that the
user passed in on the command line, and repeats, forever.
Let’s say we save this file as cpu.c and decide to compile and run it
on a system with a single processor (or CPU as we will sometimes call it).
Here is what we will see:
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
ˆC
prompt>
Not too interesting of a run — the system begins running the program,
which repeatedly checks the time until a second has elapsed. Once a second has passed, the code prints the input string passed in by the user (in
this example, the letter “A”), and continues. Note the program will run
forever; by pressing “Control-c” (which on UNIX-based systems will terminate the program running in the foreground) we can halt the program.

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 INTRODUCTION TO OPERATING SYSTEMS
prompt> ./cpu A & ./cpu B & ./cpu C & ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
...
Figure 2.2: Running Many Programs At Once
Now, let’s do the same thing, but this time, let’s run many different instances of this same program. Figure 2.2 shows the results of this slightly
more complicated example.
Well, now things are getting a little more interesting. Even though we
have only one processor, somehow all four of these programs seem to be
running at the same time! How does this magic happen?4
It turns out that the operating system, with some help from the hardware, is in charge of this illusion, i.e., the illusion that the system has
a very large number of virtual CPUs. Turning a single CPU (or a small
set of them) into a seemingly infinite number of CPUs and thus allowing
many programs to seemingly run at once is what we call virtualizing the
CPU, the focus of the first major part of this book.
Of course, to run programs, and stop them, and otherwise tell the OS
which programs to run, there need to be some interfaces (APIs) that you
can use to communicate your desires to the OS. We’ll talk about these
APIs throughout this book; indeed, they are the major way in which most
users interact with operating systems.
You might also notice that the ability to run multiple programs at once
raises all sorts of new questions. For example, if two programs want to
run at a particular time, which should run? This question is answered by
a policy of the OS; policies are used in many different places within an
OS to answer these types of questions, and thus we will study them as
we learn about the basic mechanisms that operating systems implement
(such as the ability to run multiple programs at once). Hence the role of
the OS as a resource manager.
4Note how we ran four processes at the same time, by using the & symbol. Doing so runs a
job in the background in the zsh shell, which means that the user is able to immediately issue
their next command, which in this case is another program to run. If you’re using a different
shell (e.g., tcsh), it works slightly differently; read documentation online for details.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 5
1 #include <unistd.h>
2 #include <stdio.h>
3 #include <stdlib.h>
4 #include "common.h"
5
6 int
7 main(int argc, char *argv[])
8 {
9 int *p = malloc(sizeof(int)); // a1
10 assert(p != NULL);
11 printf("(%d) address pointed to by p: %p\n",
12 getpid(), p); // a2
13 *p = 0; // a3
14 while (1) {
15 Spin(1);
16 *p = *p + 1;
17 printf("(%d) p: %d\n", getpid(), *p); // a4
18 }
19 return 0;
20 }
Figure 2.3: A Program That Accesses Memory (mem.c)
2.2 Virtualizing Memory
Now let’s consider memory. The model of physical memory presented by modern machines is very simple. Memory is just an array of
bytes; to read memory, one must specify an address to be able to access
the data stored there; to write (or update) memory, one must also specify
the data to be written to the given address.
Memory is accessed all the time when a program is running. A program keeps all of its data structures in memory, and accesses them through
various instructions, like loads and stores or other explicit instructions
that access memory in doing their work. Don’t forget that each instruction of the program is in memory too; thus memory is accessed on each
instruction fetch.
Let’s take a look at a program (in Figure 2.3) that allocates some memory by calling malloc(). The output of this program can be found here:
prompt> ./mem
(2134) address pointed to by p: 0x200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 INTRODUCTION TO OPERATING SYSTEMS
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) address pointed to by p: 0x200000
(24114) address pointed to by p: 0x200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
Figure 2.4: Running The Memory Program Multiple Times
The program does a couple of things. First, it allocates some memory
(line a1). Then, it prints out the address of the memory (a2), and then
puts the number zero into the first slot of the newly allocated memory
(a3). Finally, it loops, delaying for a second and incrementing the value
stored at the address held in p. With every print statement, it also prints
out what is called the process identifier (the PID) of the running program.
This PID is unique per running process.
Again, this first result is not too interesting. The newly allocated memory is at address 0x200000. As the program runs, it slowly updates the
value and prints out the result.
Now, we again run multiple instances of this same program to see
what happens (Figure 2.4). We see from the example that each running
program has allocated memory at the same address (0x200000), and yet
each seems to be updating the value at 0x200000 independently! It is as
if each running program has its own private memory, instead of sharing
the same physical memory with other running programs5
.
Indeed, that is exactly what is happening here as the OS is virtualizing memory. Each process accesses its own private virtual address space
(sometimes just called its address space), which the OS somehow maps
onto the physical memory of the machine. A memory reference within
one running program does not affect the address space of other processes
(or the OS itself); as far as the running program is concerned, it has physical memory all to itself. The reality, however, is that physical memory is
a shared resource, managed by the operating system. Exactly how all of
this is accomplished is also the subject of the first part of this book, on the
topic of virtualization.
5
For this example to work, you need to make sure address-space randomization is disabled; randomization, as it turns out, can be a good defense against certain kinds of security
flaws. Read more about it on your own, especially if you want to learn how to break into
computer systems via stack-smashing attacks. Not that we would recommend such a thing...
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 7
2.3 Concurrency
1 #include <stdio.h>
2 #include <stdlib.h>
3 #include "common.h"
4 #include "common_threads.h"
5
6 volatile int counter = 0;
7 int loops;
8
9 void *worker(void *arg) {
10 int i;
11 for (i = 0; i < loops; i++) {
12 counter++;
13 }
14 return NULL;
15 }
16
17 int main(int argc, char *argv[]) {
18 if (argc != 2) {
19 fprintf(stderr, "usage: threads <value>\n");
20 exit(1);
21 }
22 loops = atoi(argv[1]);
23 pthread_t p1, p2;
24 printf("Initial value : %d\n", counter);
25
26 Pthread_create(&p1, NULL, worker, NULL);
27 Pthread_create(&p2, NULL, worker, NULL);
28 Pthread_join(p1, NULL);
29 Pthread_join(p2, NULL);
30 printf("Final value : %d\n", counter);
31 return 0;
32 }
Figure 2.5: A Multi-threaded Program (threads.c)
Another main theme of this book is concurrency. We use this conceptual term to refer to a host of problems that arise, and must be addressed,
when working on many things at once (i.e., concurrently) in the same
program. The problems of concurrency arose first within the operating
system itself; as you can see in the examples above on virtualization, the
OS is juggling many things at once, first running one process, then another, and so forth. As it turns out, doing so leads to some deep and
interesting problems.
Unfortunately, the problems of concurrency are no longer limited just
to the OS itself. Indeed, modern multi-threaded programs exhibit the
same problems. Let us demonstrate with an example of a multi-threaded
program (Figure 2.5).

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 INTRODUCTION TO OPERATING SYSTEMS
Although you might not understand this example fully at the moment
(and we’ll learn a lot more about it in later chapters, in the section of the
book on concurrency), the basic idea is simple. The main program creates
two threads using Pthread create()6
. You can think of a thread as a
function running within the same memory space as other functions, with
more than one of them active at a time. In this example, each thread starts
running in a routine called worker(), in which it simply increments a
counter in a loop for loops number of times.
Below is a transcript of what happens when we run this program with
the input value for the variable loops set to 1000. The value of loops
determines how many times each of the two workers will increment the
shared counter in a loop. When the program is run with the value of
loops set to 1000, what do you expect the final value of counter to be?
prompt> gcc -o thread thread.c -Wall -pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
As you probably guessed, when the two threads are finished, the final
value of the counter is 2000, as each thread incremented the counter 1000
times. Indeed, when the input value of loops is set to N, we would
expect the final output of the program to be 2N. But life is not so simple,
as it turns out. Let’s run the same program, but with higher values for
loops, and see what happens:
prompt> ./thread 100000
Initial value : 0
Final value : 143012 // huh??
prompt> ./thread 100000
Initial value : 0
Final value : 137298 // what the??
In this run, when we gave an input value of 100,000, instead of getting
a final value of 200,000, we instead first get 143,012. Then, when we run
the program a second time, we not only again get the wrong value, but
also a different value than the last time. In fact, if you run the program
over and over with high values of loops, you may find that sometimes
you even get the right answer! So why is this happening?
As it turns out, the reason for these odd and unusual outcomes relate
to how instructions are executed, which is one at a time. Unfortunately, a
key part of the program above, where the shared counter is incremented,
6The actual call should be to lower-case pthread create(); the upper-case version is
our own wrapper that calls pthread create() and makes sure that the return code indicates
that the call succeeded. See the code for details.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 9
THE CRUX OF THE PROBLEM:
HOW TO BUILD CORRECT CONCURRENT PROGRAMS
When there are many concurrently executing threads within the same
memory space, how can we build a correctly working program? What
primitives are needed from the OS? What mechanisms should be provided by the hardware? How can we use them to solve the problems of
concurrency?
takes three instructions: one to load the value of the counter from memory into a register, one to increment it, and one to store it back into memory. Because these three instructions do not execute atomically (all at
once), strange things can happen. It is this problem of concurrency that
we will address in great detail in the second part of this book.
2.4 Persistence
The third major theme of the course is persistence. In system memory,
data can be easily lost, as devices such as DRAM store values in a volatile
manner; when power goes away or the system crashes, any data in memory is lost. Thus, we need hardware and software to be able to store data
persistently; such storage is thus critical to any system as users care a
great deal about their data.
The hardware comes in the form of some kind of input/output or I/O
device; in modern systems, a hard drive is a common repository for longlived information, although solid-state drives (SSDs) are making headway in this arena as well.
The software in the operating system that usually manages the disk is
called the file system; it is thus responsible for storing any files the user
creates in a reliable and efficient manner on the disks of the system.
Unlike the abstractions provided by the OS for the CPU and memory,
the OS does not create a private, virtualized disk for each application.
Rather, it is assumed that often times, users will want to share information that is in files. For example, when writing a C program, you might
first use an editor (e.g., Emacs7
) to create and edit the C file (emacs -nw
main.c). Once done, you might use the compiler to turn the source code
into an executable (e.g., gcc -o main main.c). When you’re finished,
you might run the new executable (e.g., ./main). Thus, you can see how
files are shared across different processes. First, Emacs creates a file that
serves as input to the compiler; the compiler uses that input file to create
a new executable file (in many steps — take a compiler course for details);
finally, the new executable is then run. And thus a new program is born!
7You should be using Emacs. If you are using vi, there is probably something wrong with
you. If you are using something that is not a real code editor, that is even worse.

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 INTRODUCTION TO OPERATING SYSTEMS
1 #include <stdio.h>
2 #include <unistd.h>
3 #include <assert.h>
4 #include <fcntl.h>
5 #include <sys/types.h>
6
7 int main(int argc, char *argv[]) {
8 int fd = open("/tmp/file", O_WRONLY|O_CREAT|O_TRUNC,
9 S_IRWXU);
10 assert(fd > -1);
11 int rc = write(fd, "hello world\n", 13);
12 assert(rc == 13);
13 close(fd);
14 return 0;
15 }
Figure 2.6: A Program That Does I/O (io.c)
To understand this better, let’s look at some code. Figure 2.6 presents
code to create a file (/tmp/file) that contains the string “hello world”.
To accomplish this task, the program makes three calls into the operating system. The first, a call to open(), opens the file and creates it; the
second, write(), writes some data to the file; the third, close(), simply closes the file thus indicating the program won’t be writing any more
data to it. These system calls are routed to the part of the operating system called the file system, which then handles the requests and returns
some kind of error code to the user.
You might be wondering what the OS does in order to actually write
to disk. We would show you but you’d have to promise to close your
eyes first; it is that unpleasant. The file system has to do a fair bit of work:
first figuring out where on disk this new data will reside, and then keeping track of it in various structures the file system maintains. Doing so
requires issuing I/O requests to the underlying storage device, to either
read existing structures or update (write) them. As anyone who has written a device driver8
knows, getting a device to do something on your
behalf is an intricate and detailed process. It requires a deep knowledge
of the low-level device interface and its exact semantics. Fortunately, the
OS provides a standard and simple way to access devices through its system calls. Thus, the OS is sometimes seen as a standard library.
Of course, there are many more details in how devices are accessed,
and how file systems manage data persistently atop said devices. For
performance reasons, most file systems first delay such writes for a while,
hoping to batch them into larger groups. To handle the problems of system crashes during writes, most file systems incorporate some kind of
intricate write protocol, such as journaling or copy-on-write, carefully
8A device driver is some code in the operating system that knows how to deal with a
specific device. We will talk more about devices and device drivers later.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 11
THE CRUX OF THE PROBLEM:
HOW TO STORE DATA PERSISTENTLY
The file system is the part of the OS in charge of managing persistent data.
What techniques are needed to do so correctly? What mechanisms and
policies are required to do so with high performance? How is reliability
achieved, in the face of failures in hardware and software?
ordering writes to disk to ensure that if a failure occurs during the write
sequence, the system can recover to reasonable state afterwards. To make
different common operations efficient, file systems employ many different data structures and access methods, from simple lists to complex btrees. If all of this doesn’t make sense yet, good! We’ll be talking about
all of this quite a bit more in the third part of this book on persistence,
where we’ll discuss devices and I/O in general, and then disks, RAIDs,
and file systems in great detail.
2.5 Design Goals
So now you have some idea of what an OS actually does: it takes physical resources, such as a CPU, memory, or disk, and virtualizes them. It
handles tough and tricky issues related to concurrency. And it stores files
persistently, thus making them safe over the long-term. Given that we
want to build such a system, we want to have some goals in mind to help
focus our design and implementation and make trade-offs as necessary;
finding the right set of trade-offs is a key to building systems.
One of the most basic goals is to build up some abstractions in order
to make the system convenient and easy to use. Abstractions are fundamental to everything we do in computer science. Abstraction makes
it possible to write a large program by dividing it into small and understandable pieces, to write such a program in a high-level language like
C
9 without thinking about assembly, to write code in assembly without
thinking about logic gates, and to build a processor out of gates without
thinking too much about transistors. Abstraction is so fundamental that
sometimes we forget its importance, but we won’t here; thus, in each section, we’ll discuss some of the major abstractions that have developed
over time, giving you a way to think about pieces of the OS.
One goal in designing and implementing an operating system is to
provide high performance; another way to say this is our goal is to minimize the overheads of the OS. Virtualization and making the system easy
to use are well worth it, but not at any cost; thus, we must strive to provide virtualization and other OS features without excessive overheads.
9
Some of you might object to calling C a high-level language. Remember this is an OS
course, though, where we’re simply happy not to have to code in assembly all the time!

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 INTRODUCTION TO OPERATING SYSTEMS
These overheads arise in a number of forms: extra time (more instructions) and extra space (in memory or on disk). We’ll seek solutions that
minimize one or the other or both, if possible. Perfection, however, is not
always attainable, something we will learn to notice and (where appropriate) tolerate.
Another goal will be to provide protection between applications, as
well as between the OS and applications. Because we wish to allow
many programs to run at the same time, we want to make sure that the
malicious or accidental bad behavior of one does not harm others; we
certainly don’t want an application to be able to harm the OS itself (as
that would affect all programs running on the system). Protection is at
the heart of one of the main principles underlying an operating system,
which is that of isolation; isolating processes from one another is the key
to protection and thus underlies much of what an OS must do.
The operating system must also run non-stop; when it fails, all applications running on the system fail as well. Because of this dependence,
operating systems often strive to provide a high degree of reliability. As
operating systems grow evermore complex (sometimes containing millions of lines of code), building a reliable operating system is quite a challenge — and indeed, much of the on-going research in the field (including
some of our own work [BS+09, SS+10]) focuses on this exact problem.
Other goals make sense: energy-efficiency is important in our increasingly green world; security (an extension of protection, really) against
malicious applications is critical, especially in these highly-networked
times; mobility is increasingly important as OSes are run on smaller and
smaller devices. Depending on how the system is used, the OS will have
different goals and thus likely be implemented in at least slightly different ways. However, as we will see, many of the principles we will present
on how to build an OS are useful on a range of different devices.
2.6 Some History
Before closing this introduction, let us present a brief history of how
operating systems developed. Like any system built by humans, good
ideas accumulated in operating systems over time, as engineers learned
what was important in their design. Here, we discuss a few major developments. For a richer treatment, see Brinch Hansen’s excellent history of
operating systems [BH00].
Early Operating Systems: Just Libraries
In the beginning, the operating system didn’t do too much. Basically,
it was just a set of libraries of commonly-used functions; for example,
instead of having each programmer of the system write low-level I/O
handling code, the “OS” would provide such APIs, and thus make life
easier for the developer.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 13
Usually, on these old mainframe systems, one program ran at a time,
as controlled by a human operator. Much of what you think a modern
OS would do (e.g., deciding what order to run jobs in) was performed by
this operator. If you were a smart developer, you would be nice to this
operator, so that they might move your job to the front of the queue.
This mode of computing was known as batch processing, as a number
of jobs were set up and then run in a “batch” by the operator. Computers,
as of that point, were not used in an interactive manner, because of cost:
it was simply too expensive to let a user sit in front of the computer and
use it, as most of the time it would just sit idle then, costing the facility
hundreds of thousands of dollars per hour [BH00].
Beyond Libraries: Protection
In moving beyond being a simple library of commonly-used services, operating systems took on a more central role in managing machines. One
important aspect of this was the realization that code run on behalf of the
OS was special; it had control of devices and thus should be treated differently than normal application code. Why is this? Well, imagine if you
allowed any application to read from anywhere on the disk; the notion of
privacy goes out the window, as any program could read any file. Thus,
implementing a file system (to manage your files) as a library makes little
sense. Instead, something else was needed.
Thus, the idea of a system call was invented, pioneered by the Atlas
computing system [K+61,L78]. Instead of providing OS routines as a library (where you just make a procedure call to access them), the idea here
was to add a special pair of hardware instructions and hardware state to
make the transition into the OS a more formal, controlled process.
The key difference between a system call and a procedure call is that
a system call transfers control (i.e., jumps) into the OS while simultaneously raising the hardware privilege level. User applications run in what
is referred to as user mode which means the hardware restricts what applications can do; for example, an application running in user mode can’t
typically initiate an I/O request to the disk, access any physical memory
page, or send a packet on the network. When a system call is initiated
(usually through a special hardware instruction called a trap), the hardware transfers control to a pre-specified trap handler (that the OS set up
previously) and simultaneously raises the privilege level to kernel mode.
In kernel mode, the OS has full access to the hardware of the system and
thus can do things like initiate an I/O request or make more memory
available to a program. When the OS is done servicing the request, it
passes control back to the user via a special return-from-trap instruction,
which reverts to user mode while simultaneously passing control back to
where the application left off.

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 INTRODUCTION TO OPERATING SYSTEMS
The Era of Multiprogramming
Where operating systems really took off was in the era of computing beyond the mainframe, that of the minicomputer. Classic machines like
the PDP family from Digital Equipment made computers hugely more
affordable; thus, instead of having one mainframe per large organization,
now a smaller collection of people within an organization could likely
have their own computer. Not surprisingly, one of the major impacts of
this drop in cost was an increase in developer activity; more smart people
got their hands on computers and thus made computer systems do more
interesting and beautiful things.
In particular, multiprogramming became commonplace due to the desire to make better use of machine resources. Instead of just running one
job at a time, the OS would load a number of jobs into memory and switch
rapidly between them, thus improving CPU utilization. This switching
was particularly important because I/O devices were slow; having a program wait on the CPU while its I/O was being serviced was a waste of
CPU time. Instead, why not switch to another job and run it for a while?
The desire to support multiprogramming and overlap in the presence
of I/O and interrupts forced innovation in the conceptual development of
operating systems along a number of directions. Issues such as memory
protection became important; we wouldn’t want one program to be able
to access the memory of another program. Understanding how to deal
with the concurrency issues introduced by multiprogramming was also
critical; making sure the OS was behaving correctly despite the presence
of interrupts is a great challenge. We will study these issues and related
topics later in the book.
One of the major practical advances of the time was the introduction
of the UNIX operating system, primarily thanks to Ken Thompson (and
Dennis Ritchie) at Bell Labs (yes, the phone company). UNIX took many
good ideas from different operating systems (particularly from Multics
[O72], and some from systems like TENEX [B+72] and the Berkeley TimeSharing System [S+68]), but made them simpler and easier to use. Soon
this team was shipping tapes containing UNIX source code to people
around the world, many of whom then got involved and added to the
system themselves; see the Aside (next page) for more detail10
.
The Modern Era
Beyond the minicomputer came a new type of machine, cheaper, faster,
and for the masses: the personal computer, or PC as we call it today. Led
by Apple’s early machines (e.g., the Apple II) and the IBM PC, this new
breed of machine would soon become the dominant force in computing,
10We’ll use asides and other related text boxes to call attention to various items that don’t
quite fit the main flow of the text. Sometimes, we’ll even use them just to make a joke, because
why not have a little fun along the way? Yes, many of the jokes are bad.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 15
ASIDE: THE IMPORTANCE OF UNIX
It is difficult to overstate the importance of UNIX in the history of operating systems. Influenced by earlier systems (in particular, the famous
Multics system from MIT), UNIX brought together many great ideas and
made a system that was both simple and powerful.
Underlying the original “Bell Labs” UNIX was the unifying principle of
building small powerful programs that could be connected together to
form larger workflows. The shell, where you type commands, provided
primitives such as pipes to enable such meta-level programming, and
thus it became easy to string together programs to accomplish a bigger task. For example, to find lines of a text file that have the word
“foo” in them, and then to count how many such lines exist, you would
type: grep foo file.txt|wc -l, thus using the grep and wc (word
count) programs to achieve your task.
The UNIX environment was friendly for programmers and developers
alike, also providing a compiler for the new C programming language.
Making it easy for programmers to write their own programs, as well as
share them, made UNIX enormously popular. And it probably helped a
lot that the authors gave out copies for free to anyone who asked, an early
form of open-source software.
Also of critical importance was the accessibility and readability of the
code. Having a beautiful, small kernel written in C invited others to play
with the kernel, adding new and cool features. For example, an enterprising group at Berkeley, led by Bill Joy, made a wonderful distribution
(the Berkeley Systems Distribution, or BSD) which had some advanced
virtual memory, file system, and networking subsystems. Joy later cofounded Sun Microsystems.
Unfortunately, the spread of UNIX was slowed a bit as companies tried to
assert ownership and profit from it, an unfortunate (but common) result
of lawyers getting involved. Many companies had their own variants:
SunOS from Sun Microsystems, AIX from IBM, HPUX (a.k.a. “H-Pucks”)
from HP, and IRIX from SGI. The legal wrangling among AT&T/Bell
Labs and these other players cast a dark cloud over UNIX, and many
wondered if it would survive, especially as Windows was introduced and
took over much of the PC market...
as their low-cost enabled one machine per desktop instead of a shared
minicomputer per workgroup.
Unfortunately, for operating systems, the PC at first represented a
great leap backwards, as early systems forgot (or never knew of) the
lessons learned in the era of minicomputers. For example, early operating systems such as DOS (the Disk Operating System, from Microsoft)
didn’t think memory protection was important; thus, a malicious (or perhaps just a poorly-programmed) application could scribble all over mem-

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
16 INTRODUCTION TO OPERATING SYSTEMS
ASIDE: AND THEN CAME LINUX
Fortunately for UNIX, a young Finnish hacker named Linus Torvalds decided to write his own version of UNIX which borrowed heavily on the
principles and ideas behind the original system, but not from the code
base, thus avoiding issues of legality. He enlisted help from many others
around the world, took advantage of the sophisticated GNU tools that
already existed [G85], and soon Linux was born (as well as the modern
open-source software movement).
As the internet era came into place, most companies (such as Google,
Amazon, Facebook, and others) chose to run Linux, as it was free and
could be readily modified to suit their needs; indeed, it is hard to imagine the success of these new companies had such a system not existed.
As smart phones became a dominant user-facing platform, Linux found
a stronghold there too (via Android), for many of the same reasons. And
Steve Jobs took his UNIX-based NeXTStep operating environment with
him to Apple, thus making UNIX popular on desktops (though many
users of Apple technology are probably not even aware of this fact). Thus
UNIX lives on, more important today than ever before. The computing
gods, if you believe in them, should be thanked for this wonderful outcome.
ory. The first generations of the Mac OS (v9 and earlier) took a cooperative approach to job scheduling; thus, a thread that accidentally got stuck
in an infinite loop could take over the entire system, forcing a reboot. The
painful list of OS features missing in this generation of systems is long,
too long for a full discussion here.
Fortunately, after some years of suffering, the old features of minicomputer operating systems started to find their way onto the desktop.
For example, Mac OS X/macOS has UNIX at its core, including all of the
features one would expect from such a mature system. Windows has similarly adopted many of the great ideas in computing history, starting in
particular with Windows NT, a great leap forward in Microsoft OS technology. Even today’s cell phones run operating systems (such as Linux)
that are much more like what a minicomputer ran in the 1970s than what
a PC ran in the 1980s (thank goodness); it is good to see that the good
ideas developed in the heyday of OS development have found their way
into the modern world. Even better is that these ideas continue to develop, providing more features and making modern systems even better
for users and applications.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 17
2.7 Summary
Thus, we have an introduction to the OS. Today’s operating systems
make systems relatively easy to use, and virtually all operating systems
you use today have been influenced by the developments we will discuss
throughout the book.
Unfortunately, due to time constraints, there are a number of parts of
the OS we won’t cover in the book. For example, there is a lot of networking code in the operating system; we leave it to you to take the networking class to learn more about that. Similarly, graphics devices are
particularly important; take the graphics course to expand your knowledge in that direction. Finally, some operating system books talk a great
deal about security; we will do so in the sense that the OS must provide
protection between running programs and give users the ability to protect their files, but we won’t delve into deeper security issues that one
might find in a security course.
However, there are many important topics that we will cover, including the basics of virtualization of the CPU and memory, concurrency, and
persistence via devices and file systems. Don’t worry! While there is a
lot of ground to cover, most of it is quite cool, and at the end of the road,
you’ll have a new appreciation for how computer systems really work.
Now get to work!

c 2008–20, ARPACI-DUSSEAU
THREE
EASY
PIECES
18 INTRODUCTION TO OPERATING SYSTEMS
References
[BS+09] “Tolerating File-System Mistakes with EnvyFS” by L. Bairavasundaram, S. Sundararaman, A. Arpaci-Dusseau, R. Arpaci-Dusseau. USENIX ’09, San Diego, CA, June 2009. A fun
paper about using multiple file systems at once to tolerate a mistake in any one of them.
[BH00] “The Evolution of Operating Systems” by P. Brinch Hansen. In ’Classic Operating
Systems: From Batch Processing to Distributed Systems.’ Springer-Verlag, New York, 2000.
This essay provides an intro to a wonderful collection of papers about historically significant systems.
[B+72] “TENEX, A Paged Time Sharing System for the PDP-10” by D. Bobrow, J. Burchfiel, D.
Murphy, R. Tomlinson. CACM, Volume 15, Number 3, March 1972. TENEX has much of the
machinery found in modern operating systems; read more about it to see how much innovation was
already in place in the early 1970’s.
[B75] “The Mythical Man-Month” by F. Brooks. Addison-Wesley, 1975. A classic text on software
engineering; well worth the read.
[BOH10] “Computer Systems: A Programmer’s Perspective” by R. Bryant and D. O’Hallaron.
Addison-Wesley, 2010. Another great intro to how computer systems work. Has a little bit of overlap
with this book — so if you’d like, you can skip the last few chapters of that book, or simply read them to
get a different perspective on some of the same material. After all, one good way to build up your own
knowledge is to hear as many other perspectives as possible, and then develop your own opinion and
thoughts on the matter. You know, by thinking!
[G85] “The GNU Manifesto” by R. Stallman. 1985. www.gnu.org/gnu/manifesto.html.
A huge part of Linux’s success was no doubt the presence of an excellent compiler, gcc, and other
relevant pieces of open software, thanks to the GNU effort headed by Stallman. Stallman is a visionary
when it comes to open source, and this manifesto lays out his thoughts as to why.
[K+61] “One-Level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner.
IRE Transactions on Electronic Computers, April 1962. The Atlas pioneered much of what you see
in modern systems. However, this paper is not the best read. If you were to only read one, you might
try the historical perspective below [L78].
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. A nice piece of history on the early development of computer systems and the pioneering efforts of the Atlas. Of course, one could go back and
read the Atlas papers themselves, but this paper provides a great overview and adds some historical
perspective.
[O72] “The Multics System: An Examination of its Structure” by Elliott Organick. MIT Press,
1972. A great overview of Multics. So many good ideas, and yet it was an over-designed system,
shooting for too much, and thus never really worked. A classic example of what Fred Brooks would call
the “second-system effect” [B75].
[PP03] “Introduction to Computing Systems: From Bits and Gates to C and Beyond” by Yale
N. Patt, Sanjay J. Patel. McGraw-Hill, 2003. One of our favorite intro to computing systems books.
Starts at transistors and gets you all the way up to C; the early material is particularly great.
[RT74] “The UNIX Time-Sharing System” by Dennis M. Ritchie, Ken Thompson. CACM, Volume 17: 7, July 1974. A great summary of UNIX written as it was taking over the world of computing,
by the people who wrote it.
[S68] “SDS 940 Time-Sharing System” by Scientific Data Systems. TECHNICAL MANUAL,
SDS 90 11168, August 1968. Yes, a technical manual was the best we could find. But it is fascinating
to read these old system documents, and see how much was already in place in the late 1960’s. One of
the minds behind the Berkeley Time-Sharing System (which eventually became the SDS system) was
Butler Lampson, who later won a Turing award for his contributions in systems.
[SS+10] “Membrane: Operating System Support for Restartable File Systems” by S. Sundararaman, S. Subramanian, A. Rajimwale, A. Arpaci-Dusseau, R. Arpaci-Dusseau, M. Swift. FAST
’10, San Jose, CA, February 2010. The great thing about writing your own class notes: you can advertise your own research. But this paper is actually pretty neat — when a file system hits a bug and
crashes, Membrane auto-magically restarts it, all without applications or the rest of the system being
affected.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
INTRODUCTION TO OPERATING SYSTEMS 19
Homework
Most (and eventually, all) chapters of this book have homework sections at the end. Doing these homeworks is important, as each lets you,
the reader, gain more experience with the concepts presented within the
chapter.
There are two types of homeworks. The first is based on simulation. A
simulation of a computer system is just a simple program that pretends to
do some of the interesting parts of what a real system does, and then report some output metrics to show how the system behaves. For example,
a hard drive simulator might take a series of requests, simulate how long
they would take to get serviced by a hard drive with certain performance
characteristics, and then report the average latency of the requests.
The cool thing about simulations is they let you easily explore how
systems behave without the difficulty of running a real system. Indeed,
they even let you create systems that cannot exist in the real world (for
example, a hard drive with unimaginably fast performance), and thus see
the potential impact of future technologies.
Of course, simulations are not without their downsides. By their very
nature, simulations are just approximations of how a real system behaves.
If an important aspect of real-world behavior is omitted, the simulation
will report bad results. Thus, results from a simulation should always be
treated with some suspicion. In the end, how a system behaves in the real
world is what matters.
The second type of homework requires interaction with real-world
code. Some of these homeworks are measurement focused, whereas others just require some small-scale development and experimentation. Both
are just small forays into the larger world you should be getting into,
which is how to write systems code in C on UNIX-based systems. Indeed,
larger-scale projects, which go beyond these homeworks, are needed to
push you in this direction; thus, beyond just doing homeworks, we strongly
recommend you do projects to solidify your systems skills. See this page
(https://github.com/remzi-arpacidusseau/ostep-projects)
for some projects.
To do these homeworks, you likely have to be on a UNIX-based machine, running either Linux, macOS, or some similar system. It should
also have a C compiler installed (e.g., gcc) as well as Python. You should
also know how to edit code in a real code editor of some kind.

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?
4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

4
The Abstraction: The Process
In this chapter, we discuss one of the most fundamental abstractions that
the OS provides to users: the process. The definition of a process, informally, is quite simple: it is a running program [V+65,BH70]. The program
itself is a lifeless thing: it just sits there on the disk, a bunch of instructions
(and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming
the program into something useful.
It turns out that one often wants to run more than one program at
once; for example, consider your desktop or laptop where you might like
to run a web browser, mail program, a game, a music player, and so forth.
In fact, a typical system may be seemingly running tens or even hundreds
of processes at the same time. Doing so makes the system easy to use, as
one never need be concerned with whether a CPU is available; one simply
runs programs. Hence our challenge:
THE CRUX OF THE PROBLEM:
HOW TO PROVIDE THE ILLUSION OF MANY CPUS?
Although there are only a few physical CPUs available, how can the
OS provide the illusion of a nearly-endless supply of said CPUs?
The OS creates this illusion by virtualizing the CPU. By running one
process, then stopping it and running another, and so forth, the OS can
promote the illusion that many virtual CPUs exist when in fact there is
only one physical CPU (or a few). This basic technique, known as time
sharing of the CPU, allows users to run as many concurrent processes as
they would like; the potential cost is performance, as each will run more
slowly if the CPU(s) must be shared.
To implement virtualization of the CPU, and to implement it well, the
OS will need both some low-level machinery and some high-level intelligence. We call the low-level machinery mechanisms; mechanisms
are low-level methods or protocols that implement a needed piece of
functionality. For example, we’ll learn later how to implement a context
1
2 THE ABSTRACTION: THE PROCESS
TIP: USE TIME SHARING (AND SPACE SHARING)
Time sharing is a basic technique used by an OS to share a resource. By
allowing the resource to be used for a little while by one entity, and then
a little while by another, and so forth, the resource in question (e.g., the
CPU, or a network link) can be shared by many. The counterpart of time
sharing is space sharing, where a resource is divided (in space) among
those who wish to use it. For example, disk space is naturally a spaceshared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.
switch, which gives the OS the ability to stop running one program and
start running another on a given CPU; this time-sharing mechanism is
employed by all modern OSes.
On top of these mechanisms resides some of the intelligence in the
OS, in the form of policies. Policies are algorithms for making some
kind of decision within the OS. For example, given a number of possible programs to run on a CPU, which program should the OS run? A
scheduling policy in the OS will make this decision, likely using historical information (e.g., which program has run more over the last minute?),
workload knowledge (e.g., what types of programs are run), and performance metrics (e.g., is the system optimizing for interactive performance,
or throughput?) to make its decision.
4.1 The Abstraction: A Process
The abstraction provided by the OS of a running program is something
we will call a process. As we said above, a process is simply a running
program; at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during
the course of its execution.
To understand what constitutes a process, we thus have to understand
its machine state: what a program can read or update when it is running.
At any given time, what parts of the machine are important to the execution of this program?
One obvious component of machine state that comprises a process is
its memory. Instructions lie in memory; the data that the running program reads and writes sits in memory as well. Thus the memory that the
process can address (called its address space) is part of the process.
Also part of the process’s machine state are registers; many instructions
explicitly read or update registers and thus clearly they are important to
the execution of the process.
Note that there are some particularly special registers that form part
of this machine state. For example, the program counter (PC) (sometimes
called the instruction pointer or IP) tells us which instruction of the program will execute next; similarly a stack pointer and associated frame
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 3
TIP: SEPARATE POLICY AND MECHANISM
In many operating systems, a common design paradigm is to separate
high-level policies from their low-level mechanisms [L+75]. You can
think of the mechanism as providing the answer to a how question about
a system; for example, how does an operating system perform a context
switch? The policy provides the answer to a which question; for example,
which process should the operating system run right now? Separating the
two allows one easily to change policies without having to rethink the
mechanism and is thus a form of modularity, a general software design
principle.
pointer are used to manage the stack for function parameters, local variables, and return addresses.
Finally, programs often access persistent storage devices too. Such I/O
information might include a list of the files the process currently has open.
4.2 Process API
Though we defer discussion of a real process API until a subsequent
chapter, here we first give some idea of what must be included in any
interface of an operating system. These APIs, in some form, are available
on any modern operating system.
• Create: An operating system must include some method to create new processes. When you type a command into the shell, or
double-click on an application icon, the OS is invoked to create a
new process to run the program you have indicated.
• Destroy: As there is an interface for process creation, systems also
provide an interface to destroy processes forcefully. Of course, many
processes will run and just exit by themselves when complete; when
they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.
• Wait: Sometimes it is useful to wait for a process to stop running;
thus some kind of waiting interface is often provided.
• Miscellaneous Control: Other than killing or waiting for a process,
there are sometimes other controls that are possible. For example,
most operating systems provide some kind of method to suspend a
process (stop it from running for a while) and then resume it (continue it running).
• Status: There are usually interfaces to get some status information
about a process as well, such as how long it has run for, or what
state it is in.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 THE ABSTRACTION: THE PROCESS
CPU Memory
Disk
code
static data
heap
stack
Process
code
static data
Program Loading:
Takes on-disk program
and reads it into the
address space of process
Figure 4.1: Loading: From Program To Process
4.3 Process Creation: A Little More Detail
One mystery that we should unmask a bit is how programs are transformed into processes. Specifically, how does the OS get a program up
and running? How does process creation actually work?
The first thing that the OS must do to run a program is to load its code
and any static data (e.g., initialized variables) into memory, into the address space of the process. Programs initially reside on disk (or, in some
modern systems, flash-based SSDs) in some kind of executable format;
thus, the process of loading a program and static data into memory requires the OS to read those bytes from disk and place them in memory
somewhere (as shown in Figure 4.1).
In early (or simple) operating systems, the loading process is done eagerly, i.e., all at once before running the program; modern OSes perform
the process lazily, i.e., by loading pieces of code or data only as they are
needed during program execution. To truly understand how lazy loading
of pieces of code and data works, you’ll have to understand more about
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 5
the machinery of paging and swapping, topics we’ll cover in the future
when we discuss the virtualization of memory. For now, just remember
that before running anything, the OS clearly must do some work to get
the important program bits from disk into memory.
Once the code and static data are loaded into memory, there are a few
other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack (or just stack).
As you should likely already know, C programs use the stack for local
variables, function parameters, and return addresses; the OS allocates
this memory and gives it to the process. The OS will also likely initialize the stack with arguments; specifically, it will fill in the parameters to
the main() function, i.e., argc and the argv array.
The OS may also allocate some memory for the program’s heap. In C
programs, the heap is used for explicitly requested dynamically-allocated
data; programs request such space by calling malloc() and free it explicitly by calling free(). The heap is needed for data structures such as
linked lists, hash tables, trees, and other interesting data structures. The
heap will be small at first; as the program runs, and requests more memory via the malloc() library API, the OS may get involved and allocate
more memory to the process to help satisfy such calls.
The OS will also do some other initialization tasks, particularly as related to input/output (I/O). For example, in UNIX systems, each process
by default has three open file descriptors, for standard input, output, and
error; these descriptors let programs easily read input from the terminal
and print output to the screen. We’ll learn more about I/O, file descriptors, and the like in the third part of the book on persistence.
By loading the code and static data into memory, by creating and initializing a stack, and by doing other work as related to I/O setup, the OS
has now (finally) set the stage for program execution. It thus has one last
task: to start the program running at the entry point, namely main(). By
jumping to the main() routine (through a specialized mechanism that
we will discuss next chapter), the OS transfers control of the CPU to the
newly-created process, and thus the program begins its execution.
4.4 Process States
Now that we have some idea of what a process is (though we will
continue to refine this notion), and (roughly) how it is created, let us talk
about the different states a process can be in at a given time. The notion
that a process can be in one of these states arose in early computer systems
[DV66,V+65]. In a simplified view, a process can be in one of three states:
• Running: In the running state, a process is running on a processor.
This means it is executing instructions.
• Ready: In the ready state, a process is ready to run but for some
reason the OS has chosen not to run it at this given moment.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 THE ABSTRACTION: THE PROCESS
Running Ready
Blocked
Descheduled
Scheduled
I/O: initiate I/O: done
Figure 4.2: Process: State Transitions
• Blocked: In the blocked state, a process has performed some kind
of operation that makes it not ready to run until some other event
takes place. A common example: when a process initiates an I/O
request to a disk, it becomes blocked and thus some other process
can use the processor.
If we were to map these states to a graph, we would arrive at the diagram in Figure 4.2. As you can see in the diagram, a process can be
moved between the ready and running states at the discretion of the OS.
Being moved from ready to running means the process has been scheduled; being moved from running to ready means the process has been
descheduled. Once a process has become blocked (e.g., by initiating an
I/O operation), the OS will keep it as such until some event occurs (e.g.,
I/O completion); at that point, the process moves to the ready state again
(and potentially immediately to running again, if the OS so decides).
Let’s look at an example of how two processes might transition through
some of these states. First, imagine two processes running, each of which
only use the CPU (they do no I/O). In this case, a trace of the state of each
process might look like this (Figure 4.3).
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready
4 Running Ready Process0 now done
5 – Running
6 – Running
7 – Running
8 – Running Process1 now done
Figure 4.3: Tracing Process State: CPU Only
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 7
Time Process0 Process1 Notes
1 Running Ready
2 Running Ready
3 Running Ready Process0 initiates I/O
4 Blocked Running Process0 is blocked,
5 Blocked Running so Process1 runs
6 Blocked Running
7 Ready Running I/O done
8 Ready Running Process1 now done
9 Running –
10 Running – Process0 now done
Figure 4.4: Tracing Process State: CPU and I/O
In this next example, the first process issues an I/O after running for
some time. At that point, the process is blocked, giving the other process
a chance to run. Figure 4.4 shows a trace of this scenario.
More specifically, Process0 initiates an I/O and becomes blocked waiting for it to complete; processes become blocked, for example, when reading from a disk or waiting for a packet from a network. The OS recognizes Process0 is not using the CPU and starts running Process1. While
Process1 is running, the I/O completes, moving Process0 back to ready.
Finally, Process1 finishes, and Process0 runs and then is done.
Note that there are many decisions the OS must make, even in this
simple example. First, the system had to decide to run Process1 while
Process0 issued an I/O; doing so improves resource utilization by keeping the CPU busy. Second, the system decided not to switch back to
Process0 when its I/O completed; it is not clear if this is a good decision or not. What do you think? These types of decisions are made by the
OS scheduler, a topic we will discuss a few chapters in the future.
4.5 Data Structures
The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. To track the state
of each process, for example, the OS likely will keep some kind of process list for all processes that are ready and some additional information to track which process is currently running. The OS must also track,
in some way, blocked processes; when an I/O event completes, the OS
should make sure to wake the correct process and ready it to run again.
Figure 4.5 shows what type of information an OS needs to track about
each process in the xv6 kernel [CK+08]. Similar process structures exist
in “real” operating systems such as Linux, Mac OS X, or Windows; look
them up and see how much more complex they are.
From the figure, you can see a couple of important pieces of information the OS tracks about a process. The register context will hold, for a

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 THE ABSTRACTION: THE PROCESS
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
int eip;
int esp;
int ebx;
int ecx;
int edx;
int esi;
int edi;
int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
char *mem; // Start of process memory
uint sz; // Size of process memory
char *kstack; // Bottom of kernel stack
// for this process
enum proc_state state; // Process state
int pid; // Process ID
struct proc *parent; // Parent process
void *chan; // If !zero, sleeping on chan
int killed; // If !zero, has been killed
struct file *ofile[NOFILE]; // Open files
struct inode *cwd; // Current directory
struct context context; // Switch here to run process
struct trapframe *tf; // Trap frame for the
// current interrupt
};
Figure 4.5: The xv6 Proc Structure
stopped process, the contents of its registers. When a process is stopped,
its registers will be saved to this memory location; by restoring these registers (i.e., placing their values back into the actual physical registers), the
OS can resume running the process. We’ll learn more about this technique
known as a context switch in future chapters.
You can also see from the figure that there are some other states a process can be in, beyond running, ready, and blocked. Sometimes a system
will have an initial state that the process is in when it is being created.
Also, a process could be placed in a final state where it has exited but
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 9
ASIDE: DATA STRUCTURE — THE PROCESS LIST
Operating systems are replete with various important data structures
that we will discuss in these notes. The process list (also called the task
list) is the first such structure. It is one of the simpler ones, but certainly
any OS that has the ability to run multiple programs at once will have
something akin to this structure in order to keep track of all the running
programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block
(PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).
has not yet been cleaned up (in UNIX-based systems, this is called the
zombie state1
). This final state can be useful as it allows other processes
(usually the parent that created the process) to examine the return code
of the process and see if the just-finished process executed successfully
(usually, programs return zero in UNIX-based systems when they have
accomplished a task successfully, and non-zero otherwise). When finished, the parent will make one final call (e.g., wait()) to wait for the
completion of the child, and to also indicate to the OS that it can clean up
any relevant data structures that referred to the now-extinct process.
4.6 Summary
We have introduced the most basic abstraction of the OS: the process.
It is quite simply viewed as a running program. With this conceptual
view in mind, we will now move on to the nitty-gritty: the low-level
mechanisms needed to implement processes, and the higher-level policies required to schedule them in an intelligent way. By combining mechanisms and policies, we will build up our understanding of how an operating system virtualizes the CPU.
1Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.
However, different techniques are usually recommended.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 THE ABSTRACTION: THE PROCESS
ASIDE: KEY PROCESS TERMS
• The process is the major OS abstraction of a running program. At
any point in time, the process can be described by its state: the contents of memory in its address space, the contents of CPU registers
(including the program counter and stack pointer, among others),
and information about I/O (such as open files which can be read or
written).
• The process API consists of calls programs can make related to processes. Typically, this includes creation, destruction, and other useful calls.
• Processes exist in one of many different process states, including
running, ready to run, and blocked. Different events (e.g., getting
scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.
• A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process
control block (PCB), which is really just a structure that contains
information about a specific process.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 11
References
[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. Communications of the ACM, Volume 13:4, April 1970. This paper introduces one of the first microkernels in
operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that
rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.
[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robert Morris, Nickolai
Zeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the
world. Download and play with it to learn more about the details of how operating systems actually
work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the
book may not match the latest in the source.
[DV66] “Programming Semantics for Multiprogrammed Computations” by Jack B. Dennis,
Earl C. Van Horn. Communications of the ACM, Volume 9, Number 3, March 1966 . This paper
defined many of the early terms and concepts around building multiprogrammed systems.
[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W. Corwin, F. Pollack,
W. Wulf. SOSP ’75, Austin, Texas, November 1975. An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of
its ideas influenced OS designers.
[V+65] “Structure of the Multics Supervisor” by V.A. Vyssotsky, F. J. Corbato, R. M. Graham.
Fall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic
ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are
finally being realized in modern cloud systems.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 THE ABSTRACTION: THE PROCESS
Homework (Simulation)
This program, process-run.py, allows you to see how process states
change as programs run and either use the CPU (e.g., perform an add
instruction) or do I/O (e.g., send a request to a disk and wait for it to
complete). See the README for details.
Questions
1. Run process-run.py with the following flags: -l 5:100,5:100.
What should the CPU utilization be (e.g., the percent of time the
CPU is in use?) Why do you know this? Use the -c and -p flags to
see if you were right.
2. Now run with these flags: ./process-run.py -l 4:100,1:0.
These flags specify one process with 4 instructions (all to use the
CPU), and one that simply issues an I/O and waits for it to be done.
How long does it take to complete both processes? Use -c and -p
to find out if you were right.
3. Switch the order of the processes: -l 1:0,4:100. What happens
now? Does switching the order matter? Why? (As always, use -c
and -p to see if you were right)
4. We’ll now explore some of the other flags. One important flag is
-S, which determines how the system reacts when a process issues an I/O. With the flag set to SWITCH ON END, the system
will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes (-l 1:0,4:100
-c -S SWITCH ON END), one doing I/O and the other doing CPU
work?
5. Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is WAITING for I/O (-l
1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c
and -p to confirm that you are right.
6. One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever
was running at the time keeps running. What happens when you
run this combination of processes? (Run ./process-run.py -l
3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER
-c -p) Are system resources being effectively utilized?
7. Now run the same processes, but with -I IO RUN IMMEDIATE set,
which immediately runs the process that issued the I/O. How does
this behavior differ? Why might running a process that just completed an I/O again be a good idea?
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
THE ABSTRACTION: THE PROCESS 13
8. Now run with some randomly generated processes: -s 1 -l 3:50,3:50
or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can
predict how the trace will turn out. What happens when you use
the flag -I IO RUN IMMEDIATE vs. -I IO RUN LATER? What happens when you use -S SWITCH ON IO vs. -S SWITCH ON END?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES

18
Paging: Introduction
It is sometimes said that the operating system takes one of two approaches
when solving most any space-management problem. The first approach
is to chop things up into variable-sized pieces, as we saw with segmentation in virtual memory. Unfortunately, this solution has inherent difficulties. In particular, when dividing a space into different-size chunks, the
space itself can become fragmented, and thus allocation becomes more
challenging over time.
Thus, it may be worth considering the second approach: to chop up
space into fixed-sized pieces. In virtual memory, we call this idea paging,
and it goes back to an early and important system, the Atlas [KE+62, L78].
Instead of splitting up a process’s address space into some number of
variable-sized logical segments (e.g., code, heap, stack), we divide it into
fixed-sized units, each of which we call a page. Correspondingly, we view
physical memory as an array of fixed-sized slots called page frames; each
of these frames can contain a single virtual-memory page. Our challenge:
THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make
those techniques work well, with minimal space and time overheads?
18.1 A Simple Example And Overview
To help make this approach more clear, let’s illustrate it with a simple
example. Figure 18.1 (page 2) presents an example of a tiny address space,
only 64 bytes total in size, with four 16-byte pages (virtual pages 0, 1, 2,
and 3). Real address spaces are much bigger, of course, commonly 32 bits
and thus 4-GB of address space, or even 64 bits1
; in the book, we’ll often
use tiny examples to make them easier to digest.
1A 64-bit address space is hard to imagine, it is so amazingly large. An analogy might
help: if you think of a 32-bit address space as the size of a tennis court, a 64-bit address space
is about the size of Europe(!).
1
2 PAGING: INTRODUCTION
64
48
32
16
0
(page 3)
(page 2)
(page 1)
(page 0 of the address space)
Figure 18.1: A Simple 64-byte Address Space
Physical memory, as shown in Figure 18.2, also consists of a number
of fixed-sized slots, in this case eight page frames (making for a 128-byte
physical memory, also ridiculously small). As you can see in the diagram,
the pages of the virtual address space have been placed at different locations throughout physical memory; the diagram also shows the OS using
some of physical memory for itself.
Paging, as we will see, has a number of advantages over our previous
approaches. Probably the most important improvement will be flexibility: with a fully-developed paging approach, the system will be able to
support the abstraction of an address space effectively, regardless of how
a process uses the address space; we won’t, for example, make assumptions about the direction the heap and stack grow and how they are used.
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
reserved for OS page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
Figure 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 3
Another advantage is the simplicity of free-space management that paging affords. For example, when the OS wishes to place our tiny 64-byte
address space into our eight-page physical memory, it simply finds four
free pages; perhaps the OS keeps a free list of all free pages for this, and
just grabs the first four free pages off of this list. In the example, the OS
has placed virtual page 0 of the address space (AS) in physical frame 3,
virtual page 1 of the AS in physical frame 7, page 2 in frame 5, and page
3 in frame 2. Page frames 1, 4, and 6 are currently free.
To record where each virtual page of the address space is placed in
physical memory, the operating system usually keeps a per-process data
structure known as a page table. The major role of the page table is to
store address translations for each of the virtual pages of the address
space, thus letting us know where in physical memory each page resides.
For our simple example (Figure 18.2, page 2), the page table would thus
have the following four entries: (Virtual Page 0 → Physical Frame 3),
(VP 1 → PF 7), (VP 2 → PF 5), and (VP 3 → PF 2).
It is important to remember that this page table is a per-process data
structure (most page table structures we discuss are per-process structures; an exception we’ll touch on is the inverted page table). If another
process were to run in our example above, the OS would have to manage
a different page table for it, as its virtual pages obviously map to different
physical pages (modulo any sharing going on).
Now, we know enough to perform an address-translation example.
Let’s imagine the process with that tiny address space (64 bytes) is performing a memory access:
movl <virtual address>, %eax
Specifically, let’s pay attention to the explicit load of the data from
address <virtual address> into the register eax (and thus ignore the
instruction fetch that must have happened prior).
To translate this virtual address that the process generated, we have
to first split it into two components: the virtual page number (VPN), and
the offset within the page. For this example, because the virtual address
space of the process is 64 bytes, we need 6 bits total for our virtual address
(2
6 = 64). Thus, our virtual address can be conceptualized as follows:
Va5 Va4 Va3 Va2 Va1 Va0
In this diagram, Va5 is the highest-order bit of the virtual address, and
Va0 the lowest-order bit. Because we know the page size (16 bytes), we
can further divide the virtual address as follows:
Va5 Va4 Va3 Va2 Va1 Va0
VPN offset

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
4 PAGING: INTRODUCTION
The page size is 16 bytes in a 64-byte address space; thus we need to
be able to select 4 pages, and the top 2 bits of the address do just that.
Thus, we have a 2-bit virtual page number (VPN). The remaining bits tell
us which byte of the page we are interested in, 4 bits in this case; we call
this the offset.
When a process generates a virtual address, the OS and hardware
must combine to translate it into a meaningful physical address. For example, let us assume the load above was to virtual address 21:
movl 21, %eax
Turning “21” into binary form, we get “010101”, and thus we can examine this virtual address and see how it breaks down into a virtual page
number (VPN) and offset:
0 1 0 1 0 1
VPN offset
Thus, the virtual address “21” is on the 5th (“0101”th) byte of virtual
page “01” (or 1). With our virtual page number, we can now index our
page table and find which physical frame virtual page 1 resides within. In
the page table above the physical frame number (PFN) (also sometimes
called the physical page number or PPN) is 7 (binary 111). Thus, we can
translate this virtual address by replacing the VPN with the PFN and then
issue the load to physical memory (Figure 18.3).
0 1 0 1 0 1
VPN offset
1 1 1 0 1 0 1
Address
Translation
PFN offset
Virtual
Address
Physical
Address
Figure 18.3: The Address Translation Process
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 5
128
112
96
80
64
48
32
16
0
page frame 7
page frame 6
page frame 5
page frame 4
page frame 3
page frame 2
page frame 1
page frame 0 of physical memory
(unused)
page 3 of AS
page 0 of AS
(unused)
page 2 of AS
(unused)
page 1 of AS
page table:
3 7 5 2
Figure 18.4: Example: Page Table in Kernel Physical Memory
Note the offset stays the same (i.e., it is not translated), because the
offset just tells us which byte within the page we want. Our final physical
address is 1110101 (117 in decimal), and is exactly where we want our
load to fetch data from (Figure 18.2, page 2).
With this basic overview in mind, we can now ask (and hopefully,
answer) a few basic questions you may have about paging. For example,
where are these page tables stored? What are the typical contents of the
page table, and how big are the tables? Does paging make the system
(too) slow? These and other beguiling questions are answered, at least in
part, in the text below. Read on!
18.2 Where Are Page Tables Stored?
Page tables can get terribly large, much bigger than the small segment
table or base/bounds pair we have discussed previously. For example,
imagine a typical 32-bit address space, with 4KB pages. This virtual address splits into a 20-bit VPN and 12-bit offset (recall that 10 bits would
be needed for a 1KB page size, and just add two more to get to 4KB).
A 20-bit VPN implies that there are 2
20 translations that the OS would
have to manage for each process (that’s roughly a million); assuming we
need 4 bytes per page table entry (PTE) to hold the physical translation
plus any other useful stuff, we get an immense 4MB of memory needed
for each page table! That is pretty large. Now imagine there are 100
processes running: this means the OS would need 400MB of memory
just for all those address translations! Even in the modern era, where

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
6 PAGING: INTRODUCTION
ASIDE: DATA STRUCTURE — THE PAGE TABLE
One of the most important data structures in the memory management
subsystem of a modern OS is the page table. In general, a page table
stores virtual-to-physical address translations, thus letting the system
know where each page of an address space actually resides in physical
memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure
of the page table is either determined by the hardware (older systems) or
can be more flexibly managed by the OS (modern systems).
machines have gigabytes of memory, it seems a little crazy to use a large
chunk of it just for translations, no? And we won’t even think about how
big such a page table would be for a 64-bit address space; that would be
too gruesome and perhaps scare you off entirely.
Because page tables are so big, we don’t keep any special on-chip hardware in the MMU to store the page table of the currently-running process.
Instead, we store the page table for each process in memory somewhere.
Let’s assume for now that the page tables live in physical memory that
the OS manages; later we’ll see that much of OS memory itself can be virtualized, and thus page tables can be stored in OS virtual memory (and
even swapped to disk), but that is too confusing right now, so we’ll ignore it. In Figure 18.4 (page 5) is a picture of a page table in OS memory;
see the tiny set of translations in there?
18.3 What’s Actually In The Page Table?
Let’s talk a little about page table organization. The page table is just
a data structure that is used to map virtual addresses (or really, virtual
page numbers) to physical addresses (physical frame numbers). Thus,
any data structure could work. The simplest form is called a linear page
table, which is just an array. The OS indexes the array by the virtual page
number (VPN), and looks up the page-table entry (PTE) at that index in
order to find the desired physical frame number (PFN). For now, we will
assume this simple linear structure; in later chapters, we will make use of
more advanced data structures to help solve some problems with paging.
As for the contents of each PTE, we have a number of different bits
in there worth understanding at some level. A valid bit is common to
indicate whether the particular translation is valid; for example, when
a program starts running, it will have code and heap at one end of its
address space, and the stack at the other. All the unused space in-between
will be marked invalid, and if the process tries to access such memory, it
will generate a trap to the OS which will likely terminate the process.
Thus, the valid bit is crucial for supporting a sparse address space; by
simply marking all the unused pages in the address space invalid, we
remove the need to allocate physical frames for those pages and thus save
a great deal of memory.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 7
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
PFN G
PAT
D
A
PCD
PWT
U/S
R/W
P
Figure 18.5: An x86 Page Table Entry (PTE)
We also might have protection bits, indicating whether the page could
be read from, written to, or executed from. Again, accessing a page in a
way not allowed by these bits will generate a trap to the OS.
There are a couple of other bits that are important but we won’t talk
about much for now. A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out). We will understand this machinery further when we study how to swap parts of the
address space to disk to support address spaces that are larger than physical memory; swapping allows the OS to free up physical memory by
moving rarely-used pages to disk. A dirty bit is also common, indicating
whether the page has been modified since it was brought into memory.
A reference bit (a.k.a. accessed bit) is sometimes used to track whether
a page has been accessed, and is useful in determining which pages are
popular and thus should be kept in memory; such knowledge is critical
during page replacement, a topic we will study in great detail in subsequent chapters.
Figure 18.5 shows an example page table entry from the x86 architecture [I09]. It contains a present bit (P); a read/write bit (R/W) which
determines if writes are allowed to this page; a user/supervisor bit (U/S)
which determines if user-mode processes can access the page; a few bits
(PWT, PCD, PAT, and G) that determine how hardware caching works for
these pages; an accessed bit (A) and a dirty bit (D); and finally, the page
frame number (PFN) itself.
Read the Intel Architecture Manuals [I09] for more details on x86 paging support. Be forewarned, however; reading manuals such as these,
while quite informative (and certainly necessary for those who write code
to use such page tables in the OS), can be challenging at first. A little patience, and a lot of desire, is required.
ASIDE: WHY NO VALID BIT?
You may notice that in the Intel example, there are no separate valid and
present bits, but rather just a present bit (P). If that bit is set (P=1), it
means the page is both present and valid. If not (P=0), it means that
the page may not be present in memory (but is valid), or may not be
valid. An access to a page with P=0 will trigger a trap to the OS; the
OS must then use additional structures it keeps to determine whether
the page is valid (and thus perhaps should be swapped back in) or not
(and thus the program is attempting to access memory illegally). This
sort of judiciousness is common in hardware, which often just provide
the minimal set of features upon which the OS can build a full service.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
8 PAGING: INTRODUCTION
18.4 Paging: Also Too Slow
With page tables in memory, we already know that they might be too
big. As it turns out, they can slow things down too. For example, take
our simple instruction:
movl 21, %eax
Again, let’s just examine the explicit reference to address 21 and not
worry about the instruction fetch. In this example, we’ll assume the hardware performs the translation for us. To fetch the desired data, the system
must first translate the virtual address (21) into the correct physical address (117). Thus, before fetching the data from address 117, the system
must first fetch the proper page table entry from the process’s page table,
perform the translation, and then load the data from physical memory.
To do so, the hardware must know where the page table is for the
currently-running process. Let’s assume for now that a single page-table
base register contains the physical address of the starting location of the
page table. To find the location of the desired PTE, the hardware will thus
perform the following functions:
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
In our example, VPN MASK would be set to 0x30 (hex 30, or binary
110000) which picks out the VPN bits from the full virtual address; SHIFT
is set to 4 (the number of bits in the offset), such that we move the VPN
bits down to form the correct integer virtual page number. For example, with virtual address 21 (010101), and masking turns this value into
010000; the shift turns it into 01, or virtual page 1, as desired. We then use
this value as an index into the array of PTEs pointed to by the page table
base register.
Once this physical address is known, the hardware can fetch the PTE
from memory, extract the PFN, and concatenate it with the offset from the
virtual address to form the desired physical address. Specifically, you can
think of the PFN being left-shifted by SHIFT, and then bitwise OR’d with
the offset to form the final address as follows:
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
Finally, the hardware can fetch the desired data from memory and put
it into register eax. The program has now succeeded at loading a value
from memory!
To summarize, we now describe the initial protocol for what happens
on each memory reference. Figure 18.6 (page 9) shows the approach. For
every memory reference (whether an instruction fetch or an explicit load
or store), paging requires us to perform one extra memory reference in
order to first fetch the translation from the page table. That is a lot of
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 9
1 // Extract the VPN from the virtual address
2 VPN = (VirtualAddress & VPN_MASK) >> SHIFT
3
4 // Form the address of the page-table entry (PTE)
5 PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7 // Fetch the PTE
8 PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12 RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14 RaiseException(PROTECTION_FAULT)
15 else
16 // Access is OK: form physical address and fetch it
17 offset = VirtualAddress & OFFSET_MASK
18 PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
19 Register = AccessMemory(PhysAddr)
Figure 18.6: Accessing Memory With Paging
work! Extra memory references are costly, and in this case will likely
slow down the process by a factor of two or more.
And now you can hopefully see that there are two real problems that
we must solve. Without careful design of both hardware and software,
page tables will cause the system to run too slowly, as well as take up
too much memory. While seemingly a great solution for our memory
virtualization needs, these two crucial problems must first be overcome.
18.5 A Memory Trace
Before closing, we now trace through a simple memory access example to demonstrate all of the resulting memory accesses that occur when
using paging. The code snippet (in C, in a file called array.c) that we
are interested in is as follows:
int array[1000];
...
for (i = 0; i < 1000; i++)
array[i] = 0;
We compile array.c and run it with the following commands:
prompt> gcc -o array array.c -Wall -O
prompt> ./array

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
10 PAGING: INTRODUCTION
Of course, to truly understand what memory accesses this code snippet (which simply initializes an array) will make, we’ll have to know (or
assume) a few more things. First, we’ll have to disassemble the resulting binary (using objdump on Linux, or otool on a Mac) to see what
assembly instructions are used to initialize the array in a loop. Here is the
resulting assembly code:
1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 0x1024
The code, if you know a little x86, is actually quite easy to understand2
.
The first instruction moves the value zero (shown as $0x0) into the virtual memory address of the location of the array; this address is computed
by taking the contents of %edi and adding %eax multiplied by four to it.
Thus, %edi holds the base address of the array, whereas %eax holds the
array index (i); we multiply by four because the array is an array of integers, each of size four bytes.
The second instruction increments the array index held in %eax, and
the third instruction compares the contents of that register to the hex
value 0x03e8, or decimal 1000. If the comparison shows that two values are not yet equal (which is what the jne instruction tests), the fourth
instruction jumps back to the top of the loop.
To understand which memory accesses this instruction sequence makes
(at both the virtual and physical levels), we’ll have to assume something
about where in virtual memory the code snippet and array are found, as
well as the contents and location of the page table.
For this example, we assume a virtual address space of size 64KB (unrealistically small). We also assume a page size of 1KB.
All we need to know now are the contents of the page table, and its
location in physical memory. Let’s assume we have a linear (array-based)
page table and that it is located at physical address 1KB (1024).
As for its contents, there are just a few virtual pages we need to worry
about having mapped for this example. First, there is the virtual page the
code lives on. Because the page size is 1KB, virtual address 1024 resides
on the second page of the virtual address space (VPN=1, as VPN=0 is
the first page). Let’s assume this virtual page maps to physical frame 4
(VPN 1 → PFN 4).
Next, there is the array itself. Its size is 4000 bytes (1000 integers),
and we assume that it resides at virtual addresses 40000 through 44000
(not including the last byte). The virtual pages for this decimal range are
VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to-physical mappings for the example: (VPN 39 → PFN 7),
(VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10).
2We are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 instructions are variable-sized.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 11
0 10 20 30 40 50
1024
1074
1124
Memory Access
Code (VA)
40000
40050
40100
Array (VA)
1024
1074
1124
1174
1224
Page Table (PA)
4096
4146
4196
Code (PA)
7232
7282
7332
Array (PA)
mov
inc
cmp jne
mov
PageTable[1]
PageTable[39]
Figure 18.7: A Virtual (And Physical) Memory Trace
We are now ready to trace the memory references of the program.
When it runs, each instruction fetch will generate two memory references:
one to the page table to find the physical frame that the instruction resides
within, and one to the instruction itself to fetch it to the CPU for processing. In addition, there is one explicit memory reference in the form of
the mov instruction; this adds another page table access first (to translate
the array virtual address to the correct physical one) and then the array
access itself.
The entire process, for the first five loop iterations, is depicted in Figure 18.7 (page 11). The bottom most graph shows the instruction memory
references on the y-axis in black (with virtual addresses on the left, and
the actual physical addresses on the right); the middle graph shows array
accesses in dark gray (again with virtual on left and physical on right); finally, the topmost graph shows page table memory accesses in light gray
(just physical, as the page table in this example resides in physical memory). The x-axis, for the entire trace, shows memory accesses across the
first five iterations of the loop; there are 10 memory accesses per loop,
which includes four instruction fetches, one explicit update of memory,
and five page table accesses to translate those four fetches and one explicit
update.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
12 PAGING: INTRODUCTION
See if you can make sense of the patterns that show up in this visualization. In particular, what will change as the loop continues to run
beyond these first five iterations? Which new memory locations will be
accessed? Can you figure it out?
This has just been the simplest of examples (only a few lines of C code),
and yet you might already be able to sense the complexity of understanding the actual memory behavior of real applications. Don’t worry: it definitely gets worse, because the mechanisms we are about to introduce only
complicate this already complex machinery. Sorry3
!
18.6 Summary
We have introduced the concept of paging as a solution to our challenge of virtualizing memory. Paging has many advantages over previous approaches (such as segmentation). First, it does not lead to external
fragmentation, as paging (by design) divides memory into fixed-sized
units. Second, it is quite flexible, enabling the sparse use of virtual address spaces.
However, implementing paging support without care will lead to a
slower machine (with many extra memory accesses to access the page
table) as well as memory waste (with memory filled with page tables instead of useful application data). We’ll thus have to think a little harder
to come up with a paging system that not only works, but works well.
The next two chapters, fortunately, will show us how to do so.
3We’re not really sorry. But, we are sorry about not being sorry, if that makes sense.
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 13
References
[KE+62] “One-level Storage System” by T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner. IRE Trans. EC-11, 2, 1962. Reprinted in Bell and Newell, “Computer Structures: Readings
and Examples”. McGraw-Hill, New York, 1971. The Atlas pioneered the idea of dividing memory
into fixed-sized pages and in many senses was an early form of the memory-management ideas we see
in modern computer systems.
[I09] “Intel 64 and IA-32 Architectures Software Developer’s Manuals” Intel, 2009. Available:
http://www.intel.com/products/processor/manuals. In particular, pay attention to “Volume
3A: System Programming Guide Part 1” and “Volume 3B: System Programming Guide Part 2”.
[L78] “The Manchester Mark I and Atlas: A Historical Perspective” by S. H. Lavington. Communications of the ACM, Volume 21:1, January 1978. This paper is a great retrospective of some of
the history of the development of some important computer systems. As we sometimes forget in the US,
many of these new ideas came from overseas.

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES
14 PAGING: INTRODUCTION
Homework (Simulation)
In this homework, you will use a simple program, which is known as
paging-linear-translate.py, to see if you understand how simple
virtual-to-physical address translation works with linear page tables. See
the README for details.
Questions
1. Before doing any translations, let’s use the simulator to study how
linear page tables change size given different parameters. Compute
the size of linear page tables as different parameters change. Some
suggested inputs are below; by using the -v flag, you can see
how many page-table entries are filled. First, to understand how
linear page table size changes as the address space grows, run with
these flags:
-P 1k -a 1m -p 512m -v -n 0
-P 1k -a 2m -p 512m -v -n 0
-P 1k -a 4m -p 512m -v -n 0
Then, to understand how linear page table size changes as page size
grows:
-P 1k -a 1m -p 512m -v -n 0
-P 2k -a 1m -p 512m -v -n 0
-P 4k -a 1m -p 512m -v -n 0
Before running any of these, try to think about the expected trends.
How should page-table size change as the address space grows? As
the page size grows? Why not use big pages in general?
2. Now let’s do some translations. Start with some small examples,
and change the number of pages that are allocated to the address
space with the -u flag. For example:
-P 1k -a 16k -p 32k -v -u 0
-P 1k -a 16k -p 32k -v -u 25
-P 1k -a 16k -p 32k -v -u 50
-P 1k -a 16k -p 32k -v -u 75
-P 1k -a 16k -p 32k -v -u 100
What happens as you increase the percentage of pages that are allocated in each address space?
3. Now let’s try some different random seeds, and some different (and
sometimes quite crazy) address-space parameters, for variety:
OPERATING
SYSTEMS
[VERSION 1.01]
WWW.OSTEP.ORG
PAGING: INTRODUCTION 15
-P 8 -a 32 -p 1024 -v -s 1
-P 8k -a 32k -p 1m -v -s 2
-P 1m -a 256m -p 512m -v -s 3
Which of these parameter combinations are unrealistic? Why?
4. Use the program to try out some other problems. Can you find the
limits of where the program doesn’t work anymore? For example,
what happens if the address-space size is bigger than physical memory?

c 2008–19, ARPACI-DUSSEAU
THREE
EASY
PIECES